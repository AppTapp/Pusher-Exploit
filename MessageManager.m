/*!
 @source MessageManager.m
 @project Pusher
 @author Alexander Maksimenko
 @copyright Copyright (c) 2009 Ripdev. All rights reserved.
 */

#import "FloatingMessage.h"
#import "MessageManager.h"

@implementation MessageManager

-(id) init
{
    self = [super init];
    
    _floatingMessage = nil;
    _floatingMessageTimer = nil;

    return self;
}

-(void) dealloc
{

    [super dealloc];
}

-(void) showBubble:(NSAttributedString*) text onSide:(MAWindowPosition) side ofView:(NSView*) view withTimeout:(int) seconds andDismissMode:(DismissMode) dismissMode
{
    NSDisableScreenUpdates();
    
    [self stopFloatingMessage];
    
    _floatingMessage = [[FloatingMessage alloc] initWithText:text ofKind:BubbleMessage onSide:side ofView:view withDismissMode:dismissMode];
    [_floatingMessage run];
    
    if(seconds > 0)
        [self startFloatingMessageTimer:seconds];

    NSEnableScreenUpdates();

    [self runFloatingMessageLoop];
}

-(void) showMessage:(NSAttributedString*) text ofKind:(MessageKind) kind withTimeout:(int) seconds buttons:(NSArray*) buttons
{
    NSDisableScreenUpdates();
    
    [self stopFloatingMessage];
    
    _floatingMessage = [[FloatingMessage alloc] initWithText:text ofKind:kind onWindow:[[InstanceManager mainController] window] buttons:buttons];
    [_floatingMessage run];
    
    if(seconds > 0)
        [self startFloatingMessageTimer:seconds];

    NSEnableScreenUpdates();

    [self runFloatingMessageLoop];
}

-(void) stopFloatingMessage
{
    if(_floatingMessage != nil)
    {
        [_floatingMessageTimer invalidate];
        _floatingMessageTimer = nil;
        
        [_floatingMessage stop];
        [_floatingMessage release];
        _floatingMessage = nil;
    }
}

-(void) startFloatingMessageTimer:(int) seconds
{
    NSInvocation* invocation = [NSInvocation invocationWithMethodSignature:[MessageManager instanceMethodSignatureForSelector:@selector(stopFloatingMessage)]];
    [invocation setSelector:@selector(stopFloatingMessage)];
    [invocation setTarget:self];

    _floatingMessageTimer = [NSTimer scheduledTimerWithTimeInterval:seconds invocation:invocation repeats:NO];
}

-(void) runFloatingMessageLoop
{
    NSDate* distantPast = [NSDate distantPast];
    NSEvent* event;
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];

    @try
    {
        while([_floatingMessage isRunning])
        {
            event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:distantPast inMode:NSDefaultRunLoopMode dequeue:YES];
            
            if(event != nil)
            {
                if([event type] == NSLeftMouseDown)
                {
                    switch([_floatingMessage dismissMode])
                    {
                        case dmNone:
                            if([event window] != [_floatingMessage window])
                                NSBeep();
                            break;
                        case dmAnyClick:
                            [self stopFloatingMessage];
                            [NSApp sendEvent:event];
                            break;
                        case dmInnerClick:
                            if([event window] == [_floatingMessage window])
                                [self stopFloatingMessage];
                            else
                                NSBeep();
                            break;
                        case dmOuterClick:
                            if([event window] != [_floatingMessage window])
                                [self stopFloatingMessage];
                            break;
                    }
                }
                
                if([event window] == [_floatingMessage window] || [event type] == NSAppKitDefined || [event type] == NSSystemDefined)
                    [NSApp sendEvent:event];
            }
        }
    }
    @catch (NSException *ex)
    {
        Log(@"%@ %@", [ex name], [ex reason]);
    }
    @finally
    {
        [pool release];
    }
}

@end
