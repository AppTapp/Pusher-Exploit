/*!
 @source SecureTask.m
 @project Pusher
 @author Alexander Maksimenko
 @copyright Copyright (c) 2009 Ripdev. All rights reserved.
 */

#import "SecureTask.h"

@implementation SecureTask

-(id) init
{
    self = [super init];

    authorizationRef = NULL;
    _output = [[NSMutableString alloc] init];
    _helperPath = [[[[NSBundle mainBundle] bundlePath] stringByAppendingPathComponent:PusherHelperPath] retain];
    
    return self;
}

-(void) dealloc
{
    [self deauthenticate];
    
    [_output release];
    [_helperPath release];

    [super dealloc];
}

-(BOOL) isAuthenticated:(NSString*) task
{
    OSStatus err = 0;

    if(authorizationRef == NULL)
    {
        err = AuthorizationCreate (NULL, kAuthorizationEmptyEnvironment, kAuthorizationFlagDefaults, &authorizationRef);    
        
        if(err != errAuthorizationSuccess)
            return NO;
    }

    AuthorizationFlags flags;
    AuthorizationRights rights;
    AuthorizationItem items[1];
    const char* taskC = [task UTF8String];

    items[0].name = kAuthorizationRightExecute;
    items[0].value = (void*)taskC;
    items[0].valueLength = strlen(taskC);
    items[0].flags = 0;

    rights.count = 1;
    rights.items = items;
    
    flags = kAuthorizationFlagExtendRights;
    
    err = AuthorizationCopyRights(authorizationRef,&rights,kAuthorizationEmptyEnvironment,flags,NULL);

    return (err == errAuthorizationSuccess);
}

-(void) deauthenticate
{
    if(authorizationRef)
    {
        AuthorizationFree(authorizationRef,kAuthorizationFlagDestroyRights);
        authorizationRef = NULL;
    }
}

-(BOOL) fetchPassword:(NSString*) task
{
    OSStatus err = 0;
    AuthorizationFlags flags;
    AuthorizationRights rights;
    AuthorizationItem items[1];
    const char* taskC = [task UTF8String];

    items[0].name = kAuthorizationRightExecute;
    items[0].value = (void*)taskC;
    items[0].valueLength = strlen(taskC);
    items[0].flags = 0;
    
    rights.count = 1;
    rights.items = items;
    
    flags = kAuthorizationFlagDefaults | 
            kAuthorizationFlagInteractionAllowed | 
            kAuthorizationFlagExtendRights;

    err = AuthorizationCopyRights(authorizationRef,&rights,kAuthorizationEmptyEnvironment,flags,NULL);

    return (err == errAuthorizationSuccess);
}

-(BOOL) authenticate:(NSString*) task
{
    if(![self isAuthenticated:task])
        [self fetchPassword:task];

    return [self isAuthenticated:task];
}

-(BOOL) runTaskWithArgs:(char * const *) args
{
    if(![self authenticate:_helperPath])
    {
        Log(@"Failed to authenticate helper execution");
        return FALSE;
    }

    FILE* f = NULL;
    OSStatus err = AuthorizationExecuteWithPrivileges(authorizationRef, [_helperPath UTF8String], 0, args, &f);
    
	if(err == errAuthorizationSuccess)
    {
		// wait for child process to end
		pid_t pid = [self readPid:f];
		[self drainOutput:f];
		
		int status;
		
//		Log(@"Waiting for pwange helper with pid %d", pid);
		
		if(waitpid(pid, &status, 0) != pid)
        {
            Log(@"Failed to waitpid helper pid");
			return NO;
        }
		
		if(!WIFEXITED(status))
        {
            Log(@"Failed to waitpid(), returned %d", status);
			return NO;
        }
    }
    else
        Log(@"Failed to AuthorizationExecuteWithPrivileges(), returned %d", err);
	
    return (err == errAuthorizationSuccess);
}

-(void) drainOutput:(FILE*) file
{
    [_output setString:@""];

    int c = 0;
    char buffer[100];

    for(;;)
    {
        c = fread(buffer, 1, sizeof(buffer), file);
        
        if(c < 1)
            break;
        
        fwrite(buffer, 1, c, stdout);

        buffer[c] = 0;
        [_output appendString:[NSString stringWithUTF8String:&buffer[0]]];
    }

    fclose(file);
}

-(int) readPid:(FILE*) file
{
	pid_t pid = 0;
	char pidnum[1024];

	int i = 0;
	char ch = 0;
	while(fread(&ch, 1, sizeof(ch), file) == sizeof(ch) && (ch != '\n') && (i < sizeof(pidnum)))
		pidnum[i++] = ch;

	pidnum[i] = 0;

	if(ch != '\n')
		return -1;
	
	sscanf(pidnum, "%d", &pid);
	
	if(pid == 0)
		return -1;
	
	return pid;
}

-(NSString*) output
{
    return _output;
}

@end
