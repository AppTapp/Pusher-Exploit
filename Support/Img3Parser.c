/*!
 @source Img3Parser.c
 @project Pusher
 @author Alexander Maksimenko
 @copyright Copyright (c) 2009 Ripdev. All rights reserved.
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <openssl/sha.h>
#include <openssl/aes.h>
#include "png.h"
#include "zlib.h"
#include "RootFSDecrypt.h"
#include "8900Parser.h"
#include "Img3Parser.h"
#include "compression.h"

int parseImg3(const char* filename, hImg3* pHeaderImg3, Img3Element* pElement, hKernel* pHeaderKernel, hBootIm* pHeaderBootIm, int* pFlags, int extract, const char* output, const char* key, const char* iv)
{
	FILE *in;
    Img3Element* pDataElement;
	Img3Element* pNewElement;
    unsigned char *inbuf, *p;
    unsigned int size, paddedSize;
    int ret = 0;
	
    *pFlags = 0;
	
    in = fopen(filename, "rb");
    if(!in)
    {
        fprintf(stderr, "ERR: Could not open '%s' for reading.\n", filename);
        return -1;
    }
	
    fseek(in, 0, SEEK_END);
    size = ftell(in);
    rewind(in);
	
    printf("... Begin parsing Img3 file.\n");
	
    if(size < sizeof(hImg3))
    {
        fprintf(stderr, "ERR: Incorrect Img3 file '%s'. Filesize is less than should be.\n", filename);
        fclose(in);
        return -1;
    }
	
    inbuf = (unsigned char *)malloc(size);
    fread(inbuf, 1, size, in);
    fclose(in);
	
    p = inbuf;
    memcpy(pHeaderImg3, p, sizeof(hImg3));
	
    if(endian_swap(pHeaderImg3->magic) != 'Img3')
    {
        fprintf(stderr, "ERR: Incorrect Img3 file '%s'. Wrong magic value.\n", filename);
        free(inbuf);
        return -2;
    }
	
    p += sizeof(hImg3);
	
	memcpy(&pElement->header, p, sizeof(hImg3Element));
	pElement->data = (unsigned char*)malloc(endian_swap(pElement->header.dataSize));
	memcpy(pElement->data, p + sizeof(hImg3Element), endian_swap(pElement->header.dataSize));
	p += endian_swap(pElement->header.size);
	
	pElement->nextElement = 0;

    if(key != 0 && iv != 0)
    {
        paddedSize = endian_swap(pElement->header.dataSize);
        paddedSize = (paddedSize % AES_BLOCK_SIZE == 0) ? paddedSize : (paddedSize / AES_BLOCK_SIZE) * AES_BLOCK_SIZE;
    
        aes_decrypt(pElement->data, paddedSize, key, iv);
    }

    pNewElement = pElement;
	
	while((unsigned int)(p - inbuf) < size)
	{
		pNewElement->nextElement = (Img3Element*)malloc(sizeof(Img3Element));
		pNewElement = pNewElement->nextElement;
		
		memcpy(&pNewElement->header, p, sizeof(hImg3Element));
		pNewElement->data = (unsigned char*)malloc(endian_swap(pNewElement->header.dataSize));
		memcpy(pNewElement->data, p + sizeof(hImg3Element), endian_swap(pNewElement->header.dataSize));
		p += endian_swap(pNewElement->header.size);
		
		pNewElement->nextElement = 0;
	}
    
    pDataElement = getDataElement(pElement);
    
	memcpy(pHeaderKernel, pDataElement->data, sizeof(hKernel));
	if(endian_swap(pHeaderKernel->magic) == swap32('comp'))
	{
		*pFlags |= IsKernelFile;
		
		printf("... KernelCache file found.\n");
	}
    else
	{
		memcpy(pHeaderBootIm, pDataElement->data, sizeof(hBootIm));
		
		if(strcmp(pHeaderBootIm->magic,"iBootIm") == 0)
		{
			*pFlags |= IsBootImFile;
			
			printf("... iBootIm file found.\n");
		}
		else
		{
			*pFlags |= IsPlainFile;
			
			printf("... Plain file found.\n");
		}
	}

    if(extract)
        ret = extractImg3File(pDataElement, pHeaderKernel, pHeaderBootIm, pFlags, output, key, iv);

    if(ret != 0)
        freeElements(pElement);

    free(inbuf);
	
	return ret;
}

int extractImg3File(Img3Element* pElement, hKernel* pHeaderKernel, hBootIm* pHeaderBootIm, int* pFlags, const char* filename, const char* key, const char* iv)
{
    FILE *out;
    unsigned char *outbuf, *p;
    unsigned int size, imSize;
	
    out = fopen(filename, "wb");
    if(!out)
    {
        fprintf(stderr, "ERR: Could not open '%s' for writing.\n", filename);
        return -1;
    }
	
	p = pElement->data;
	size = endian_swap(pElement->header.dataSize);
    
    if((*pFlags & IsKernelFile) == IsKernelFile)
    {
        printf("... Decompressing KernelCache file.\n");
		
		p += sizeof(hKernel);
		size = endian_swap(swap32(pHeaderKernel->compressed_size));
		
        outbuf = (unsigned char *)malloc(endian_swap(swap32(pHeaderKernel->uncompressed_size)));
        memset(outbuf, 0, endian_swap(swap32(pHeaderKernel->uncompressed_size)));
        size = decompress_lzss(outbuf, p, size);
		
        if(size != endian_swap(swap32(pHeaderKernel->uncompressed_size)))
        {
            fprintf(stderr, "ERR: Incorrect un-compressed kernel cache size: %d != %d.\n", size, endian_swap(swap32(pHeaderKernel->uncompressed_size)));
            free(outbuf);
            return -1;
        }
    }
    else if((*pFlags & IsBootImFile) == IsBootImFile)
    {
		imSize = endian_swap(pHeaderBootIm->width) * endian_swap(pHeaderBootIm->height);
		
		if(endian_swap(pHeaderBootIm->type) == 'argb')
			imSize *= 4;
		else if(endian_swap(pHeaderBootIm->type) == 'grey')
			imSize *= 2;
		else
		{
			fprintf(stderr, "ERR: Unknown iBootIm file type: %08X.\n", endian_swap(pHeaderBootIm->type));
			return -1;
		}
		
		printf("... Decompressing iBootIm file.\n");
		
		p += sizeof(hBootIm);
		size -= sizeof(hBootIm);
		
		outbuf = (unsigned char *)malloc(imSize);
		memset(outbuf, 0, imSize);
		size = decompress_lzss(outbuf, p, size);
		
		if(size != imSize)
		{
			fprintf(stderr, "ERR: Incorrect un-compressed iBootIm file size: %d != %d.\n", size, imSize);
			free(outbuf);
			return -1;
		}
	}
    else // Plain file
    {
        outbuf = (unsigned char *)malloc(size);
        memcpy(outbuf, p, size);
    }
	
    printf("... Writing extracted file.\n");
	
    fwrite(outbuf, 1, size, out);
    free(outbuf);
    fclose(out);
	
    return 0;	
}

int doImg3File(const char* filename, hImg3* pHeaderImg3, Img3Element* pElement, hKernel* pHeaderKernel, hBootIm* pHeaderBootIm, int* pFlags, const char* output, const char* key, const char* iv)
{
    FILE *in, *out;
    Img3Element* pDataElement;
    unsigned char *inbuf, *outbuf, *end, *p;
    unsigned int size, paddedSize;
	
    in = fopen(filename, "rb");
    if(!in)
    {
        fprintf(stderr, "ERR: Could not open '%s' for reading.\n", filename);
        return -1;
    }
	
    out = fopen(output, "wb");
    if(!out)
    {
        fprintf(stderr, "ERR: Could not open '%s' for writing.\n", filename);
        fclose(in);
        return -1;
    }
	
    fseek(in, 0, SEEK_END);
    size = ftell(in);
    rewind(in);
	
    printf("... Begin injecting new file.\n");
	
	if((*pFlags & IsKernelFile) == IsKernelFile)
    {
		inbuf = (unsigned char *)malloc(size);
		fread(inbuf, 1, size, in);
		fclose(in);
		
		pHeaderKernel->adler32 = swap32(local_adler32(inbuf, size));
		pHeaderKernel->uncompressed_size = swap32(size);
		
		printf("... Compressing KernelCache file.\n");
		
		end = compress_lzss(inbuf, size, inbuf, size);
		size = (unsigned int)(end - inbuf);
		pHeaderKernel->compressed_size = swap32(size);
		
		pHeaderKernel->adler32 = endian_swap(pHeaderKernel->adler32);
		pHeaderKernel->uncompressed_size = endian_swap(pHeaderKernel->uncompressed_size);
		pHeaderKernel->compressed_size = endian_swap(pHeaderKernel->compressed_size);
		
		pDataElement = getDataElement(pElement);
		pDataElement->header.dataSize = sizeof(hKernel) + size;
		pDataElement->header.size = pDataElement->header.dataSize + sizeof(hImg3Element);

		pDataElement->header.dataSize = endian_swap(pDataElement->header.dataSize);
		pDataElement->header.size = endian_swap(pDataElement->header.size);
		
		free(pDataElement->data);
        
		pDataElement->data = (unsigned char*)malloc(endian_swap(pDataElement->header.dataSize));
		memcpy(pDataElement->data, pHeaderKernel, sizeof(hKernel));
		memcpy(pDataElement->data + sizeof(hKernel), inbuf, size);
		
		free(inbuf);
	}
    else if((*pFlags & IsBootImFile) == IsBootImFile)
	{
		unsigned int width, height, gray;
		
		printf("... Converting PNG to iBootIm file.\n");
		
		inbuf = read_png(in, &width, &height, &gray);
		fclose(in);
		
		if(inbuf == 0)
		{  // Invalid PNG data
			printf("... Invalid PNG data.\n");
			return -1;
		}
		
		if(gray)
		{
			pHeaderBootIm->type = endian_swap('grey');
			size = width * height * 2;
		}
		else
		{
			pHeaderBootIm->type = endian_swap('argb');
			size = width * height * 4;
		}
		
		pHeaderBootIm->width = endian_swap16((unsigned short)width);
		pHeaderBootIm->height = endian_swap16((unsigned short)height);
		
		printf("... Compressing iBootIm file.\n");
		
		end = compress_lzss(inbuf, size, inbuf, size);
		size = (unsigned int)(end - inbuf);
		
		pDataElement = getDataElement(pElement);
		pDataElement->header.dataSize = sizeof(hBootIm) + size;
		pDataElement->header.size = pDataElement->header.dataSize + sizeof(hImg3Element);
		
		pDataElement->header.dataSize = endian_swap(pDataElement->header.dataSize);
		pDataElement->header.size = endian_swap(pDataElement->header.size);
		
		free(pDataElement->data);

		pDataElement->data = (unsigned char*)malloc(endian_swap(pDataElement->header.dataSize));
		memcpy(pDataElement->data, pHeaderBootIm, sizeof(hBootIm));
		memcpy(pDataElement->data + sizeof(hBootIm), inbuf, size);
		
		free(inbuf);
	}
	else
	{
		inbuf = (unsigned char *)malloc(size);
		fread(inbuf, 1, size, in);
		fclose(in);
		
		pDataElement = getDataElement(pElement);
		pDataElement->header.dataSize = size;
		pDataElement->header.size = pDataElement->header.dataSize + sizeof(hImg3Element);
		
		pDataElement->header.dataSize = endian_swap(pDataElement->header.dataSize);
		pDataElement->header.size = endian_swap(pDataElement->header.size);
		
		free(pDataElement->data);

		pDataElement->data = (unsigned char*)malloc(endian_swap(pDataElement->header.dataSize));
		memcpy(pDataElement->data, inbuf, size);
		
		free(inbuf);		
	}
	
    if(key != 0 && iv != 0)
    {
        paddedSize = endian_swap(pElement->header.dataSize);
        paddedSize = (paddedSize % AES_BLOCK_SIZE == 0) ? paddedSize : (paddedSize / AES_BLOCK_SIZE) * AES_BLOCK_SIZE;
        
        aes_encrypt(pDataElement->data, paddedSize, key, iv);
    }
        
	pHeaderImg3->imageSize = getElementsSize(pElement);
	pHeaderImg3->size = pHeaderImg3->imageSize + sizeof(hImg3);
	pHeaderImg3->shshOffset = getSHSHOffset(pElement);

	outbuf = (unsigned char *)malloc(pHeaderImg3->size);
	memset(outbuf, 0, pHeaderImg3->size);
	
	pHeaderImg3->imageSize = endian_swap(pHeaderImg3->imageSize);
	pHeaderImg3->size = endian_swap(pHeaderImg3->size);
	pHeaderImg3->shshOffset = endian_swap(pHeaderImg3->shshOffset);
	
	p = outbuf;
	memcpy(p, pHeaderImg3, sizeof(hImg3));
	p += sizeof(hImg3);
	
	while(pElement)
	{
		memcpy(p, &pElement->header, sizeof(hImg3Element));
		memcpy(p + sizeof(hImg3Element), pElement->data, endian_swap(pElement->header.dataSize));
		p += endian_swap(pElement->header.size);
		
		pElement = pElement->nextElement;
	}
	
	fwrite(outbuf, 1, endian_swap(pHeaderImg3->size), out);
	free(outbuf);
	fclose(out);
	
	if((*pFlags & IsKernelFile) == IsKernelFile)
		printf("... KernelCache file injected.\n");
    else if((*pFlags & IsBootImFile) == IsBootImFile)
		printf("... iBootIm file injected.\n");
	else
		printf("... Plain file injected.\n");
	
    return 0;
}

Img3Element* getDataElement(Img3Element* pElement)
{
	while(pElement)
	{
		if(endian_swap(pElement->header.magic) == 'DATA')
        {
            printf("... Data size %d.\n", endian_swap(pElement->header.dataSize));
            return pElement;
        }

		pElement = pElement->nextElement;
	}
	
	return NULL;
}

unsigned int getElementsSize(Img3Element* pElement)
{
	unsigned int size = 0;
	
	while(pElement)
	{
		size += endian_swap(pElement->header.size);
		
		pElement = pElement->nextElement;
	}
	
	return size;
}

unsigned int getSHSHOffset(Img3Element* pElement)
{
	unsigned int offset = 0;
	
	while(pElement)
	{
		if(endian_swap(pElement->header.magic) == 'SHSH')
			return offset;

		offset += endian_swap(pElement->header.size);
		
		pElement = pElement->nextElement;
	}
	
	return 0;
}

void freeElements(Img3Element* pElement)
{
	Img3Element* p;

    free(pElement->data);
	pElement = pElement->nextElement;
	
	while(pElement)
	{
		free(pElement->data);
		
		p = pElement;
		pElement = pElement->nextElement;
		
		free(p);
	}
}

void aes_decrypt(void* p, unsigned int size, const char* key, const char* iv)
{
    AES_KEY dctx;
    unsigned char aes_key[AES_BLOCK_SIZE] = {0};
    unsigned char aes_iv[AES_BLOCK_SIZE] = {0};

    convert_hex(key, aes_key, AES_BLOCK_SIZE);
    convert_hex(iv, aes_iv, AES_BLOCK_SIZE);

    AES_set_decrypt_key( aes_key, 128, &dctx );
    AES_cbc_encrypt(p, p, size, &dctx, aes_iv, AES_DECRYPT);
}

void aes_encrypt(void* p, unsigned int size, const char* key, const char* iv)
{
    AES_KEY ectx;
    unsigned char aes_key[AES_BLOCK_SIZE] = {0};
    unsigned char aes_iv[AES_BLOCK_SIZE] = {0};

    convert_hex(key, aes_key, AES_BLOCK_SIZE);
    convert_hex(iv, aes_iv, AES_BLOCK_SIZE);

    AES_set_encrypt_key( aes_key, 128, &ectx );
    AES_cbc_encrypt(p, p, size, &ectx, aes_iv, AES_ENCRYPT);    
}
