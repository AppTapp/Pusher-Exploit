/*!
 @source OpenSSLHelper.m
 @project Pusher
 @author Alexander Maksimenko
 @copyright Copyright (c) 2009 Ripdev. All rights reserved.
 */

#import <openssl/sha.h>
#import <openssl/md5.h>
#import <openssl/aes.h>
#import "OpenSSLHelper.h"

#define DATA_READ_SIZE 1000000

unsigned char update_key[AES_BLOCK_SIZE] = {0x42, 0x41, 0x53, 0x48, 0x5F, 0x56, 0x45, 0x52, 0x53, 0x49, 0x4F, 0x4E, 0x09, 0x31, 0x2E, 0x30};

@implementation OpenSSLHelper

+(NSString*) shaStringForData:(NSData*) data
{
    return [OpenSSLHelper shaStringForBytes:[data bytes] withSize:[data length]];
}

+(NSString*) shaStringForBytes:(const void*) data withSize:(unsigned int) size
{
    SHA_CTX sctx;

    unsigned int i = 0;
    unsigned char md[SHA_DIGEST_LENGTH] = {0};

    SHA1_Init(&sctx);
    SHA1_Update(&sctx,data,size);
    SHA1_Final(&(md[0]),&sctx);
    
    NSMutableString* result = [[[NSMutableString alloc] init] autorelease];
   
    for(;i < SHA_DIGEST_LENGTH;i++)
        [result appendFormat:@"%02X", md[i]];
        
    return result;
}

+(NSString*) shaStringForFile:(NSString*) file
{
    NSFileHandle* fh = [NSFileHandle fileHandleForReadingAtPath:file];
    SHA_CTX sctx;

    unsigned int i = 0;
    unsigned char md[SHA_DIGEST_LENGTH] = {0};

    SHA1_Init(&sctx);

    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
    NSData* data = [fh readDataOfLength:DATA_READ_SIZE];
    
    while([data length] > 0)
    {
        SHA1_Update(&sctx,[data bytes],[data length]);

        [pool release];
        pool = [[NSAutoreleasePool alloc] init];

        data = [fh readDataOfLength:DATA_READ_SIZE];
    }

    [pool release];

    SHA1_Final(&(md[0]),&sctx);
    
    NSMutableString* result = [[[NSMutableString alloc] init] autorelease];
   
    for(;i < SHA_DIGEST_LENGTH;i++)
        [result appendFormat:@"%02X", md[i]];

    return result;
}

+(NSString*) md5StringForData:(NSData*) data
{
    return [OpenSSLHelper md5StringForBytes:[data bytes] withSize:[data length]];
}

+(NSString*) md5StringForBytes:(const void*) data withSize:(unsigned int) size
{
    MD5_CTX sctx;

    unsigned int i = 0;
    unsigned char md[MD5_DIGEST_LENGTH] = {0};

    MD5_Init(&sctx);
    MD5_Update(&sctx,data,size);
    MD5_Final(&(md[0]),&sctx);
    
    NSMutableString* result = [[[NSMutableString alloc] init] autorelease];
   
    for(;i < MD5_DIGEST_LENGTH;i++)
        [result appendFormat:@"%02X", md[i]];
        
    return result;
}

+(void*) updateFile:(NSString*) file with:(AES_MODE) mode
{
    NSFileHandle* fh = [NSFileHandle fileHandleForUpdatingAtPath:file];
    unsigned char iv[AES_BLOCK_SIZE] = {0};
    unsigned long long pos = 0;

    NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
    NSMutableData* data = [[[fh readDataOfLength:AES_BLOCK_SIZE * 32] mutableCopy] autorelease];
    
    while([data length] > 0)
    {
        void* p = [data mutableBytes];
        unsigned len = [data length];
        
        if(mode)
            [OpenSSLHelper aesEncrypt:p size:len key:update_key iv:iv];
        else
            [OpenSSLHelper aesDecrypt:p size:len key:update_key iv:iv];

        [fh seekToFileOffset:pos];
        [fh writeData:data];

        pos += len;
        
        [pool release];
        pool = [[NSAutoreleasePool alloc] init];

        data = [[[fh readDataOfLength:AES_BLOCK_SIZE * 32] mutableCopy] autorelease];
    }

    [pool release];

    [fh closeFile];

    return NULL;
}

+(void) aesEncrypt:(void*) buf size:(int) size key:(void*) key iv:(void*) iv
{
    AES_KEY ectx;
    AES_set_encrypt_key( key, 128, &ectx );
    AES_cbc_encrypt(buf, buf, size, &ectx, iv, AES_ENCRYPT );
}

+(void) aesDecrypt:(void*) buf size:(int) size key:(void*) key iv:(void*) iv
{
    AES_KEY dctx;
    AES_set_decrypt_key( key, 128, &dctx );
    AES_cbc_encrypt(buf, buf, size, &dctx, iv, AES_DECRYPT );
}

@end