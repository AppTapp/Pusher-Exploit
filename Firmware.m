/*!
 @source Firmware.m
 @project Pusher
 @author Alexander Maksimenko
 @copyright Copyright (c) 2009 Ripdev. All rights reserved.
 */

#import "FirmwareBundle.h"
#import "8900Parser.h"
#import "Img3Parser.h"
#import "Firmware.h"

@implementation Firmware

-(id) initWithBundle:(FirmwareBundle*) bundle path:(NSString*) path
{
    self = [super init];
    
    _bundle = [bundle retain];
    _path = [path copy];

    return self;
}

-(void) dealloc
{
    [_bundle release];
    [_path release];
    
    [super dealloc];
}

-(void) encodeWithCoder:(NSCoder*) encoder
{
	[encoder encodeObject:_bundle];
	[encoder encodeObject:_path];
}

-(id) initWithCoder:(NSCoder*) decoder
{
    [_bundle release];
    _bundle = [[decoder decodeObject] retain];
    
    [_path release];
    _path = [[decoder decodeObject] copy];

	return self;
}

-(NSString*) path
{
    return [[_path copy] autorelease];
}

-(NSString*) name
{
    return [_bundle name];
}

-(int) version
{
    return [_bundle version];
}

-(Platform) platform
{
    return [_bundle platform];
}

-(NSString*) filename
{
    return [_bundle filename];
}

-(NSString*) bundlePath
{
    return [_bundle path];
}

-(NSString*) rootFilesystem
{
    return [_bundle rootFilesystem];
}

-(NSString*) rootFilesystemKey
{
    return [_bundle rootFilesystemKey];
}

-(NSString*) rootFilesystemMountVolume
{
    return [_bundle rootFilesystemMountVolume];
}

-(double) rootFilesystemSize
{
    return [_bundle rootFilesystemSize];
}

-(double) rootFilesystemUsedSpace
{
    return [_bundle rootFilesystemUsedSpace];
}

-(NSString*) ramdiskMountVolume
{
    return [_bundle ramdiskMountVolume];
}

-(NSString*) allFlashDir
{
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWIBootKey];

    return [[dict objectForKey:FileKey] stringByDeletingLastPathComponent];
}

-(NSString*) appleLogoFile
{
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWAppleLogoKey];

    return [dict objectForKey:FileKey];
}

-(NSString*) iBootFile
{
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWIBootKey];

    return [dict objectForKey:FileKey];
}

-(NSString*) iBSSFile
{
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWIBSSKey];

    return [dict objectForKey:FileKey];
}

-(NSString*) wtfFile
{
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWWTF2Key];

    return [dict objectForKey:FileKey];
}

-(NSString*) restoreRamdiskFile
{
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWRestoreRamdiskKey];

    return [dict objectForKey:FileKey];
}

-(NSString*) deviceTreeFile
{
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWDeviceTreeKey];

    return [dict objectForKey:FileKey];
}

-(NSString*) kernelCacheFile
{
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWKernelCacheKey];

    return [dict objectForKey:FileKey];
}

-(NSArray*) preInstalledCustomPackages
{
    return [_bundle preInstalledCustomPackages];
}

-(NSDictionary*) firmwarePatches
{
    return [_bundle firmwarePatches];
}

-(NSDictionary*) filesystemPatches
{
    return [_bundle filesystemPatches];
}

-(NSDictionary*) basebandPatches
{
    return [_bundle basebandPatches];
}

-(BOOL) bbUpdateAvailable
{
    return [_bundle bbUpdateAvailable];
}

-(BOOL) phoneActivationAvailable
{
    return [_bundle phoneActivationAvailable];
}

-(BOOL) unzipTo:(NSString*) path
{
    // Unzip original IPSW to Temp Dir
    
    NSTask* unzip = [[[NSTask alloc] init] autorelease];

    [unzip setArguments:[NSArray arrayWithObjects:
        @"-d", path,
        @"-o",
        [self path],
        nil]];
    [unzip setLaunchPath:@"/usr/bin/unzip"];
    [unzip launch];
    [unzip waitUntilExit];

    return ([unzip terminationStatus] == 0);
}

-(BOOL) extractRamdisk:(RamdiskType) type to:(NSString*) file
{
    h8900 header8900;
    f8900 footer8900;
    hImg2 headerImg2;
	hImg3 headerImg3;
	Img3Element img3Element;
    hBootIm headerBootIm;
    hKernel headerKernel;
    int flags, ret;

    NSString* ramdiskKey = nil;
    
    switch(type)
    {
        case rtRestore:
            ramdiskKey = FWRestoreRamdiskKey;
            break;
        case rtUpdate:
            ramdiskKey = FWUpdateRamdiskKey;
            break;
    }
    
    if(ramdiskKey == nil)
        return NO;
        
    NSFileManager* fileManager = [NSFileManager defaultManager];
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:ramdiskKey];
	NSString* ramdisk = [SystemTempDir stringByAppendingPathComponent:[dict objectForKey:FileKey]];
    NSString* key = [dict objectForKey:KeyKey];
    NSString* iv = [dict objectForKey:IVKey];    
    
	ret = parseImg3([ramdisk UTF8String], &headerImg3, &img3Element, &headerKernel, &headerBootIm, &flags, 1, [file UTF8String], (key != nil ? [key UTF8String] : 0), (iv != nil ? [iv UTF8String] : 0));
	if(ret == 0 && (flags & 8) == 8)
	{
		freeElements(&img3Element);
	}
	else if(ret == -2)
	{
		if(parse8900([ramdisk UTF8String], &header8900, &footer8900, &headerKernel, &headerImg2, &headerBootIm, &flags, 1, [file UTF8String]) != 0 || (flags & 8) != 8)
		{
			[fileManager removeFileAtPath:ramdisk handler:nil];
			return NO;
		}
	}
	else
		[fileManager removeFileAtPath:ramdisk handler:nil];
    
    return YES;
}

-(BOOL) makeRamdisk:(RamdiskType) type from:(NSString*) file encrypt:(BOOL) encrypt
{
    h8900 header8900;
    f8900 footer8900;
    hImg2 headerImg2;
	hImg3 headerImg3;
	Img3Element img3Element;
    hBootIm headerBootIm;
    hKernel headerKernel;
    int flags, ret;

    NSString* ramdiskKey = nil;
    
    switch(type)
    {
        case rtRestore:
            ramdiskKey = FWRestoreRamdiskKey;
            break;
        case rtUpdate:
            ramdiskKey = FWUpdateRamdiskKey;
            break;
    }
    
    if(ramdiskKey == nil)
        return NO;
        
    NSFileManager* fileManager = [NSFileManager defaultManager];
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:ramdiskKey];
	NSString* ramdisk = [SystemTempDir stringByAppendingPathComponent:[dict objectForKey:FileKey]];
    NSString* key = (encrypt ? [dict objectForKey:KeyKey] : nil);
    NSString* iv = (encrypt ? [dict objectForKey:IVKey] : nil);

	ret = parseImg3([ramdisk UTF8String], &headerImg3, &img3Element, &headerKernel, &headerBootIm, &flags, 0, 0, (key != nil ? [key UTF8String] : 0), (iv != nil ? [iv UTF8String] : 0));
	if(ret == 0 && (flags & 8) == 8)
	{
		if(![fileManager removeFileAtPath:ramdisk handler:nil])
		{
			freeElements(&img3Element);
			return NO;
		}

		if(doImg3File([file UTF8String], &headerImg3, &img3Element, &headerKernel, &headerBootIm, &flags, [ramdisk UTF8String], (key != nil ? [key UTF8String] : 0), (iv != nil ? [iv UTF8String] : 0)) != 0)
		{
			freeElements(&img3Element);
			return NO;
		}
		
		freeElements(&img3Element);
	}
	else if(ret == -2)
	{
		if(parse8900([ramdisk UTF8String], &header8900, &footer8900, &headerKernel, &headerImg2, &headerBootIm, &flags, 0, 0) != 0 || (flags & 8) != 8)
			return NO;

		if(![fileManager removeFileAtPath:ramdisk handler:nil])
			return NO;

        if(doPlainFile([file UTF8String], &header8900, &footer8900, [ramdisk UTF8String], NO) != 0)
			return NO;
	}
    
    return YES;
}

+(BOOL) checkCustomPicture:(NSString*) file
{
    return check_png([file UTF8String]);
}

-(BOOL) makeBootLogo:(NSString*) file
{
    h8900 header8900;
    f8900 footer8900;
    hImg2 headerImg2;
	hImg3 headerImg3;
	Img3Element img3Element;
    hBootIm headerBootIm;
    hKernel headerKernel;
    int flags, ret;

    NSFileManager* fileManager = [NSFileManager defaultManager];
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWAppleLogoKey];
	NSString* bootLogo = [SystemTempDir stringByAppendingPathComponent:[dict objectForKey:FileKey]];
    NSString* key = [dict objectForKey:KeyKey];
    NSString* iv = [dict objectForKey:IVKey];    

	ret = parseImg3([bootLogo UTF8String], &headerImg3, &img3Element, &headerKernel, &headerBootIm, &flags, 0, 0, (key != nil ? [key UTF8String] : 0), (iv != nil ? [iv UTF8String] : 0));
	if(ret == 0 && (flags & 2) == 2)
	{
		if(![fileManager removeFileAtPath:bootLogo handler:nil])
		{
			freeElements(&img3Element);
			return NO;
		}

		if(doImg3File([file UTF8String], &headerImg3, &img3Element, &headerKernel, &headerBootIm, &flags, [bootLogo UTF8String], (key != nil ? [key UTF8String] : 0), (iv != nil ? [iv UTF8String] : 0)) != 0)
		{
			freeElements(&img3Element);
			return NO;
		}
		
		freeElements(&img3Element);
	}
	else if(ret == -2)
	{
		if(parse8900([bootLogo UTF8String], &header8900, &footer8900, &headerKernel, &headerImg2, &headerBootIm, &flags, 0, 0) != 0 || (flags & 2) != 2)
			return NO;

		if(![fileManager removeFileAtPath:bootLogo handler:nil])
			return NO;

		if(doBootImFile([file UTF8String], &header8900, &footer8900, &headerImg2, &headerBootIm, [bootLogo UTF8String]) != 0)
			return NO;
	}
	
    return YES;
}

-(BOOL) makeRecoveryLogo:(NSString*) file
{
    h8900 header8900;
    f8900 footer8900;
    hImg2 headerImg2;
	hImg3 headerImg3;
	Img3Element img3Element;
    hBootIm headerBootIm;
    hKernel headerKernel;
    int flags, ret;

    NSFileManager* fileManager = [NSFileManager defaultManager];
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWRecoveryModeKey];
	NSString* recoveryLogo = [SystemTempDir stringByAppendingPathComponent:[dict objectForKey:FileKey]];
    NSString* key = [dict objectForKey:KeyKey];
    NSString* iv = [dict objectForKey:IVKey];    
    
	ret = parseImg3([recoveryLogo UTF8String], &headerImg3, &img3Element, &headerKernel, &headerBootIm, &flags, 0, 0, (key != nil ? [key UTF8String] : 0), (iv != nil ? [iv UTF8String] : 0));
	if(ret == 0 && (flags & 2) == 2)
	{
		if(![fileManager removeFileAtPath:recoveryLogo handler:nil])
		{
			freeElements(&img3Element);
			return NO;
		}
		
		if(doImg3File([file UTF8String], &headerImg3, &img3Element, &headerKernel, &headerBootIm, &flags, [recoveryLogo UTF8String], (key != nil ? [key UTF8String] : 0), (iv != nil ? [iv UTF8String] : 0)) != 0)
		{
			freeElements(&img3Element);
			return NO;
		}
		
		freeElements(&img3Element);
	}
	else if(ret == -2)
	{
		if(parse8900([recoveryLogo UTF8String], &header8900, &footer8900, &headerKernel, &headerImg2, &headerBootIm, &flags, 0, 0) != 0 || (flags & 2) != 2)
			return NO;

		if(![fileManager removeFileAtPath:recoveryLogo handler:nil])
			return NO;

		if(doBootImFile([file UTF8String], &header8900, &footer8900, &headerImg2, &headerBootIm, [recoveryLogo UTF8String]) != 0)
			return NO;
	}
	
    return YES;
}

-(BOOL) patchIBoot
{
    NSDictionary* dict = [[_bundle firmwarePatches] objectForKey:FWIBootKey];

    int type = [[dict objectForKey:TypeFlagKey] intValue];
    NSString* file = [SystemTempDir stringByAppendingPathComponent:[dict objectForKey:FileKey]];
    NSString* patch = [[_bundle path] stringByAppendingPathComponent:[dict objectForKey:PatchKey]];
    NSString* key = [dict objectForKey:KeyKey];
    NSString* iv = [dict objectForKey:IVKey];    

    return [self patchFirmwareModule:file ofType:type withPatch:patch key:key iv:iv exploit:NO];
}

-(BOOL) patchFirmwareModule:(NSString*) file ofType:(int) type withPatch:(NSString*) patch key:(NSString*) key iv:(NSString*) iv exploit:(BOOL) exploit
{
    h8900 header8900;
    f8900 footer8900;
    hImg2 headerImg2;
	hImg3 headerImg3;
	Img3Element img3Element;
    hBootIm headerBootIm;
    hKernel headerKernel;
    int flags, ret;

    NSFileManager* fileManager = [NSFileManager defaultManager];
    NSString* tempFile = [file stringByAppendingPathExtension:@"bin"];

	ret = parseImg3([file UTF8String], &headerImg3, &img3Element, &headerKernel, &headerBootIm, &flags, 1, [tempFile UTF8String], (key != nil ? [key UTF8String] : 0), (iv != nil ? [iv UTF8String] : 0));
	if(ret == 0)
	{
        if((flags & type) == type)
        {
            // Apply Patch
			
            if(![self applyPatch:patch toFile:tempFile])
            {
				freeElements(&img3Element);
				return NO;
			}
    
			if(doImg3File([tempFile UTF8String], &headerImg3, &img3Element, &headerKernel, &headerBootIm, &flags, [file UTF8String], (key != nil ? [key UTF8String] : 0), (iv != nil ? [iv UTF8String] : 0)) != 0)
			{
				freeElements(&img3Element);
				return NO;
			}
            
            [fileManager removeFileAtPath:tempFile handler:nil];
			freeElements(&img3Element);
        }
		else
		{
			freeElements(&img3Element);
			return NO;
		}
	}
    else if(ret == -2)
	{
		if(parse8900([file UTF8String], &header8900, &footer8900, &headerKernel, &headerImg2, &headerBootIm, &flags, 1, [tempFile UTF8String]) == 0)
		{
			if((flags & type) == type)
			{
				// Apply Patch

				if(![self applyPatch:patch toFile:tempFile])
					return NO;
				
				switch(type)
				{
					case 1: // Img2 (iBoot/DeviceTree)
						if(doImg2File([tempFile UTF8String], &header8900, &footer8900, &headerImg2, [file UTF8String]) != 0)
							return NO;
						break;
					case 2: // iBootIm (Pictures)
						break;
					case 4: // KernelCache
						if(doKernelFile([tempFile UTF8String], &header8900, &footer8900, &headerKernel, [file UTF8String]) != 0)
							return NO;
						break;
					case 8: // Plain file (Ramdisk/iBEC/iBSS)
						if(doPlainFile([tempFile UTF8String], &header8900, &footer8900, [file UTF8String], exploit) != 0)
							return NO;
						break;
					default:
						return NO;
				}
				
				[fileManager removeFileAtPath:tempFile handler:nil];
			}
			else return NO;
		}
	}
    else return NO;

    return YES;
}

-(BOOL) applyPatch:(NSString*) patch toFile:(NSString*) file
{
    NSTask* bspatch = [[[NSTask alloc] init] autorelease];
    
    [bspatch setArguments:[NSArray arrayWithObjects:
        file,
        file,
        patch,
        nil]];
    [bspatch setLaunchPath:@"/usr/bin/bspatch"];
    [bspatch launch];
    [bspatch waitUntilExit];

    if([bspatch terminationStatus] != 0)
        return NO;

    return YES;
}

@end
