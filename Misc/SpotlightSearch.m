/*!
 @source SpotlightSearch.m
 @project Pusher
 @author Alexander Maksimenko
 @copyright Copyright (c) 2009 Ripdev. All rights reserved.
 */

#import <sys/sysctl.h>
#import "SpotlightSearch.h"

@implementation SpotlightSearch

-(id) init
{
    self = [super init];
    
    _mdQuery = [[NSMetadataQuery alloc] init];
    _results = [[NSMutableArray alloc] init];

	[[NSNotificationCenter defaultCenter] addObserver:self
		selector:@selector(queryHandler:)
		name:NSMetadataQueryDidFinishGatheringNotification object:_mdQuery];
    
    _isSpotlightAvailable = [self isSpotlightAvailable];
    
    return self;
}

-(void) dealloc
{
    [_mdQuery release];
    [_results release];

    [[NSNotificationCenter defaultCenter] removeObserver:self];
    
    [super dealloc];
}

-(BOOL) isSpotlightAvailable
{
    int err;
    struct kinfo_proc* result_ptr = NULL;
    static const int name[] = { CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0 };
    size_t length;
    BOOL done = NO;
    
    do
    {
        length = 0;

        err = sysctl((int*)name, (sizeof(name) / sizeof(*name)) - 1, NULL, &length, NULL, 0);

        if(err == -1)
            err = errno;

        if(err == 0)
        {
            result_ptr = (struct kinfo_proc*)malloc(length);

            if(result_ptr == NULL)
                err = ENOMEM;
        }

        if(err == 0)
        {
            err = sysctl((int*)name, (sizeof(name) / sizeof(*name)) - 1, result_ptr, &length, NULL, 0);

            if(err == -1)
                err = errno;

            if(err == 0)
            {
                done = YES;
            }
            else if(err == ENOMEM)
            {
                result_ptr = NULL;
                err = 0;
            }
        }
    }
    while(err == 0 && done == NO);

    if(err != 0 && result_ptr != NULL)
    {
        free(result_ptr);
        result_ptr = NULL;
    }

    BOOL result = NO;
    
	if(result_ptr != NULL)
	{
		int count = length / sizeof(struct kinfo_proc);
        int i = 0;
        
		for(i = 0; i < count; ++i)
        {
            struct kinfo_proc kp = result_ptr[i];
			if(strcmp(kp.kp_proc.p_comm, "mds") == 0)
            {
                result = YES;
                break;
            }
        }
        
		free(result_ptr);
	}    

    return result;
}

-(NSArray*) searchFilesWithContentType:(NSString*) contentType name:(NSString*) name size:(int) size
{
    [_results removeAllObjects];

    if(_isSpotlightAvailable)
    {
        _searchDidFinish = NO;
        _searchName = name;
        _searchSize = size;

        NSString* queryString = [NSString stringWithFormat:@"kMDItemContentType == '%@'", contentType];
        NSPredicate* predicate = [NSPredicate predicateWithFormat: queryString];
        [_mdQuery setPredicate:predicate];
        [_mdQuery startQuery];

        while(!_searchDidFinish)
            [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.1]];
    }

    return _results;
}

-(void) queryHandler:(NSNotification*) notification
{   
	NSEnumerator* enumerator = [[_mdQuery results] objectEnumerator];
	NSMetadataItem* item;
	while(item = [enumerator nextObject])
    {
        NSString* fsName = [item valueForAttribute:@"kMDItemFSName"];
        NSNumber* fsSize = [item valueForAttribute:@"kMDItemFSSize"];
        NSString* path = [item valueForAttribute:@"kMDItemPath"];
        
        if(fsName != nil && fsSize != nil && path != nil)
            if(_searchName == nil || [fsName isEqualToString:_searchName])
                if(_searchSize == 0 || [fsSize intValue] == _searchSize)
                    [_results addObject:path];
    }
    
    _searchDidFinish = YES;
}

@end
