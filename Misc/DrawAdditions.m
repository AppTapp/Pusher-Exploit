/*!
 @source DrawAdditions.m
 @project Pusher
 @author Alexander Maksimenko
 @copyright Copyright (c) 2009 Ripdev. All rights reserved.
 */

#import "DrawAdditions.h"

@implementation NSBezierPath (RoundedRects)

-(void) appendRoundedTop:(NSRect) rect radius:(float) radius
{
	float radControl = radius * 0.5;

    [self moveToPoint:NSMakePoint(rect.origin.x, rect.origin.y + rect.size.height - radius)];
    [self relativeCurveToPoint:NSMakePoint(radius, radius) controlPoint1:NSMakePoint(0, radControl) controlPoint2:NSMakePoint (radius - radControl, radius)];
    [self relativeLineToPoint:NSMakePoint(rect.size.width - 2 * radius, 0)];
    [self relativeCurveToPoint:NSMakePoint(radius, -radius) controlPoint1:NSMakePoint(radControl, 0) controlPoint2:NSMakePoint (radius, radControl - radius)];
}

-(void) appendRoundedBottom:(NSRect) rect radius:(float) radius
{
	float radControl = radius * 0.5;

    [self moveToPoint:NSMakePoint(rect.origin.x, rect.origin.y + radius)];
    [self relativeCurveToPoint:NSMakePoint(radius, -radius) controlPoint1:NSMakePoint(0, -radControl) controlPoint2:NSMakePoint (radius - radControl, -radius)];
    [self relativeLineToPoint:NSMakePoint(rect.size.width - 2 * radius, 0)];
    [self relativeCurveToPoint:NSMakePoint(radius, radius) controlPoint1:NSMakePoint(radControl, 0) controlPoint2:NSMakePoint (radius, radius - radControl)];
}

-(void) appendRoundedRect:(NSRect) rect radius:(float) radius
{
    [self appendRoundedRect:rect corners:ALL_CORNERS radius:radius];
}

-(void) appendRoundedRect:(NSRect) rect radiusX:(float) radiusX radiusY:(float) radiusY
{
    [self appendRoundedRect:rect corners:ALL_CORNERS radiusX:radiusX radiusY:radiusY];
}

-(void) appendRoundedRect:(NSRect) rect corners:(int) corners radius:(float) radius
{
    [self appendRoundedRect:rect corners:corners radiusX:radius radiusY:radius];
}

-(void) appendRoundedRect:(NSRect) rect corners:(int) corners radiusX:(float) radiusX radiusY:(float) radiusY
{
	// if the radius is larger than the rectangle, slim it down
	if(radiusX > rect.size.width / 2.0)
		radiusX = rect.size.width / 2.0;

    if(radiusY > rect.size.height / 2.0)
		radiusY = rect.size.height / 2.0;
        
    float radControlX = radiusX * 0.5522847498;
	float radControlY = radiusY * 0.5522847498;

	// inner rect is offset by the radius on each side
	NSRect innerRect = NSMakeRect(rect.origin.x + radiusX, rect.origin.y + radiusY, rect.size.width - radiusX * 2, rect.size.height - radiusY * 2 );

	// starting in the lower left corner
    if((corners & LEFT_BOTTOM_CORNER) == LEFT_BOTTOM_CORNER)
        [self moveToPoint:NSMakePoint(rect.origin.x, innerRect.origin.y)];
    else
        [self moveToPoint:NSMakePoint(rect.origin.x, rect.origin.y)];

	// left side
    if((corners & LEFT_BOTTOM_CORNER) == LEFT_BOTTOM_CORNER && (corners & LEFT_TOP_CORNER) == LEFT_TOP_CORNER)
        [self relativeLineToPoint:NSMakePoint(0, innerRect.size.height)];
    else if((corners & LEFT_BOTTOM_CORNER) == LEFT_BOTTOM_CORNER || (corners & LEFT_TOP_CORNER) == LEFT_TOP_CORNER)
        [self relativeLineToPoint:NSMakePoint(0, rect.size.height - radiusY)];
    else
        [self relativeLineToPoint:NSMakePoint(0, rect.size.height)];

	// upper left corner
    if((corners & LEFT_TOP_CORNER) == LEFT_TOP_CORNER)
        [self relativeCurveToPoint:NSMakePoint(radiusX,radiusY) controlPoint1:NSMakePoint(0,radControlY) controlPoint2:NSMakePoint(radiusX - radControlX, radiusY)];

	// top side
    if((corners & LEFT_TOP_CORNER) == LEFT_TOP_CORNER && (corners & RIGHT_TOP_CORNER) == RIGHT_TOP_CORNER)
        [self relativeLineToPoint:NSMakePoint(innerRect.size.width, 0)];
    else if((corners & LEFT_TOP_CORNER) == LEFT_TOP_CORNER || (corners & RIGHT_TOP_CORNER) == RIGHT_TOP_CORNER)
        [self relativeLineToPoint:NSMakePoint(rect.size.width - radiusX, 0)];
    else
        [self relativeLineToPoint:NSMakePoint(rect.size.width, 0)];
    
	// upper right corner
    if((corners & RIGHT_TOP_CORNER) == RIGHT_TOP_CORNER)
        [self relativeCurveToPoint:NSMakePoint(radiusX, -radiusY) controlPoint1:NSMakePoint(radControlX, 0) controlPoint2:NSMakePoint(radiusX, radControlY - radiusY)];

	// right side
    if((corners & RIGHT_TOP_CORNER) == RIGHT_TOP_CORNER && (corners & RIGHT_BOTTOM_CORNER) == RIGHT_BOTTOM_CORNER)
        [self relativeLineToPoint:NSMakePoint(0, -innerRect.size.height)];
    else if((corners & RIGHT_TOP_CORNER) == RIGHT_TOP_CORNER || (corners & RIGHT_BOTTOM_CORNER) == RIGHT_BOTTOM_CORNER)
        [self relativeLineToPoint:NSMakePoint(0, -(rect.size.height - radiusY))];
    else
        [self relativeLineToPoint:NSMakePoint(0, -rect.size.height)];

	// lower right corner
    if((corners & RIGHT_BOTTOM_CORNER) == RIGHT_BOTTOM_CORNER)
        [self relativeCurveToPoint:NSMakePoint(-radiusX, -radiusY) controlPoint1:NSMakePoint(0, -radControlY) controlPoint2:NSMakePoint (radControlX - radiusX, -radiusY)];

	// bottom side
    if((corners & RIGHT_BOTTOM_CORNER) == RIGHT_BOTTOM_CORNER && (corners & LEFT_BOTTOM_CORNER) == LEFT_BOTTOM_CORNER)
        [self relativeLineToPoint:NSMakePoint(-innerRect.size.width, 0)];
    else if((corners & RIGHT_BOTTOM_CORNER) == RIGHT_BOTTOM_CORNER || (corners & LEFT_BOTTOM_CORNER) == LEFT_BOTTOM_CORNER)
        [self relativeLineToPoint:NSMakePoint(-(rect.size.width - radiusX), 0)];
    else
        [self relativeLineToPoint:NSMakePoint(-rect.size.width, 0)];

	// lower left corner
    if((corners & LEFT_BOTTOM_CORNER) == LEFT_BOTTOM_CORNER)
        [self relativeCurveToPoint:NSMakePoint(-radiusX, radiusY) controlPoint1:NSMakePoint(-radControlX, 0) controlPoint2:NSMakePoint(-radiusX, radControlY)];
}

static void linearShadedColor(void* info, const float* in, float* out)
{
	float* colors = info;
	*out++ = colors[0] + *in * colors[8];
	*out++ = colors[1] + *in * colors[9];
	*out++ = colors[2] + *in * colors[10];
	*out++ = colors[3] + *in * colors[11];
}

static void bilinearShadedColor(void* info, const float* in, float* out)
{
	float* colors = info;
	float factor = (*in) * 2.0;

	if (*in < 0.5)
        factor = 2.0 - factor;
        
	*out++ = colors[0] + factor * colors[8];
	*out++ = colors[1] + factor * colors[9];
	*out++ = colors[2] + factor * colors[10];
	*out++ = colors[3] + factor * colors[11];
}

-(void) linearGradientFillWithStartColor:(NSColor*) startColor endColor:(NSColor*) endColor
{
	static const CGFunctionCallbacks callbacks = {0, &linearShadedColor, NULL};
	
	[self customVerticalFillWithCallbacks:callbacks firstColor:startColor secondColor:endColor];
}

-(void) bilinearGradientFillWithOuterColor:(NSColor*) outerColor innerColor:(NSColor*) innerColor
{
	static const CGFunctionCallbacks callbacks = {0, &bilinearShadedColor, NULL};

	[self customVerticalFillWithCallbacks:callbacks firstColor:innerColor secondColor:outerColor];
}

-(void) customVerticalFillWithCallbacks:(CGFunctionCallbacks) functionCallbacks firstColor:(NSColor*) firstColor secondColor:(NSColor*) secondColor
{
	CGColorSpaceRef colorspace;
	CGShadingRef shading;
	CGPoint startPoint = {0, 0};
	CGPoint endPoint = {0, 0};
	CGFunctionRef function;
	float colors[12]; // pointer to color values
	
	// get my context
	CGContextRef currentContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
	
	NSColor *deviceDependentFirstColor = [firstColor colorUsingColorSpaceName:NSDeviceRGBColorSpace];
	NSColor *deviceDependentSecondColor = [secondColor colorUsingColorSpaceName:NSDeviceRGBColorSpace];
	
	// set up colors for gradient
	colors[0] = [deviceDependentFirstColor redComponent];
	colors[1] = [deviceDependentFirstColor greenComponent];
	colors[2] = [deviceDependentFirstColor blueComponent];
	colors[3] = [deviceDependentFirstColor alphaComponent];
	
	colors[4] = [deviceDependentSecondColor redComponent];
	colors[5] = [deviceDependentSecondColor greenComponent];
	colors[6] = [deviceDependentSecondColor blueComponent];
	colors[7] = [deviceDependentSecondColor alphaComponent];
	
	// difference between start and end color for each color components
	colors[8] = (colors[4]-colors[0]);
	colors[9] = (colors[5]-colors[1]);
	colors[10] = (colors[6]-colors[2]);
	colors[11] = (colors[7]-colors[3]);
	
	// draw gradient
#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_4
	colorspace = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
#else
	colorspace = CGColorSpaceCreateDeviceRGB();
#endif
	size_t components = 1 + CGColorSpaceGetNumberOfComponents(colorspace);
	static const float  domain[2] = {0.0, 1.0};
	static const float  range[10] = {0, 1, 0, 1, 0, 1, 0, 1, 0, 1};
	
	// Create a CGFunctionRef that describes a function taking 1 input and kChannelsPerColor outputs.
	function = CGFunctionCreate(colors, 1, domain, components, range, &functionCallbacks);
	
	startPoint.x = 0;
	startPoint.y = [self bounds].origin.y;
	endPoint.x = 0;
	endPoint.y = NSMaxY([self bounds]);
	
	shading = CGShadingCreateAxial(colorspace, startPoint, endPoint, function, NO, NO);
	
	CGContextSaveGState(currentContext);
	[self addClip];
	CGContextDrawShading(currentContext, shading);
	CGContextRestoreGState(currentContext);
	
	CGShadingRelease(shading);
	CGFunctionRelease(function);
	CGColorSpaceRelease(colorspace);
}

@end

@implementation NSColor (RGBA)

+(NSColor*) colorWithRGBA:(unsigned int) rgba
{
//    Log(@"colorWithRGBA - RGBA: %u, R:%f G:%f B:%f A:%f", rgba, (float)(rgba >> 24) / 255, (float)((rgba >> 16) & 0xFF) / 255, (float)((rgba >> 8) & 0xFF) / 255, (float)(rgba & 0xFF) / 255);
    return [NSColor colorWithDeviceRed:(float)(rgba >> 24) / 255 green:(float)((rgba >> 16) & 0xFF) / 255 blue:(float)((rgba >> 8) & 0xFF) / 255 alpha:(float)(rgba & 0xFF) / 255];
}

@end