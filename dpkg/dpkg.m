#import <fcntl.h>
#import "dpkg.h"


#define DPKG_OUTPUT "/tmp/dpkg.log"

@interface DpkgManager (Private)

-(void) clearOutput;
-(NSString*) readOutput;
-(NSString*) readStatus;

-(NSMutableArray*) dependencyFromString:(NSString*) string;

@end

@implementation DpkgManager (Private)

-(void) clearOutput
{
    unlink(DPKG_OUTPUT);
}

-(NSString*) readOutput
{
    NSString* output = [NSString stringWithContentsOfFile:[NSString stringWithUTF8String:DPKG_OUTPUT]];
    output = [output stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];

    return output;
}

-(NSString*) readStatus
{
    NSString* status = [self readOutput];    
    NSArray* lines = [status componentsSeparatedByString:@"\n"];
    status = [lines lastObject];
    
    return status;
}

-(NSMutableArray*) dependencyFromString:(NSString*) string
{
    NSMutableArray* result = nil;
    
    if(string != nil)
    {
        NSArray* components = [string componentsSeparatedByString:@","];
        if([components count] > 0)
        {
            NSString* dependString = nil;
            
            for(dependString in components)
            {
                NSString* correctDependString = dependString;
                
                NSRange findedRange = [correctDependString rangeOfString:@"("];
                if(findedRange.location < [correctDependString length])
                    correctDependString = [correctDependString substringToIndex:(findedRange.location - 1)];
                
                correctDependString = [correctDependString stringByTrimmingCharactersInSet:[NSCharacterSet characterSetWithCharactersInString:@" "]];
                
                if([correctDependString length] > 0)
                {
                    if(result == nil)
                        result = [NSMutableArray arrayWithCapacity:0];
                    
                    [result addObject:[correctDependString lowercaseString]];
                }
            }
        }
    }
    
    return result;
}

@end

@implementation DpkgManager

-(id) init
{
	self = [super init];
    
    return self;
}

-(void) dealloc
{
    [self clearOutput];
    
    [super dealloc];
}

-(NSArray*) packages
{
    NSMutableArray* packages = [NSMutableArray array];
    NSMutableDictionary* dict = [NSMutableDictionary dictionary];
    NSString* desc = nil;
    BOOL isInstalled = NO;
    
    NSString* file = [NSString stringWithContentsOfFile:@"/var/lib/dpkg/status"];
    if(file)
    {
        NSArray* lines = [file componentsSeparatedByString:@"\n"]; 
        NSEnumerator* enumerator = [lines objectEnumerator];
        NSString* line;
        while(line = [enumerator nextObject])
        {
            NSRange range = [line rangeOfString:@" " options:0 range:NSMakeRange(0, [line length])];
            if(range.location != NSNotFound)
            {
                NSString* key = [line substringToIndex:range.location];
                NSString* value = [line substringFromIndex:range.location + 1];
                
                if([key isEqualToString:@"Status:"])
                    isInstalled = [value isEqualToString:@"install ok installed"];
                else if([key isEqualToString:@"Package:"])
                    [dict setObject:value forKey:PackageIdKey];
                else if([key isEqualToString:@"Name:"])
                    [dict setObject:value forKey:PackageNameKey];
                else if([key isEqualToString:@"Version:"])
                    [dict setObject:value forKey:PackageVersionKey];
                else if([key isEqualToString:@"Description:"])
                    desc = value;
                else if([key isEqualToString:@"Section:"])
                    [dict setObject:value forKey:PackageCategoryKey];
                else if([key isEqualToString:@"Depends:"])
                {
                    NSArray* dependency = [self dependencyFromString:value];
                    if(dependency)
                        [dict setObject:dependency forKey:PackageDependencyKey];
                }
                else if([key isEqualToString:@"Author:"])
                    [dict setObject:value forKey:PackageAuthorKey];
                else if([key isEqualToString:@"Maintainer:"])
                    [dict setObject:value forKey:PackageMaintainerKey];
                else if([key isEqualToString:@"Essential:"] && [value isEqualToString:@"yes"])
                    [dict setObject:[NSNumber numberWithBool:YES] forKey:PackageEssentialKey];
                else if([key isEqualToString:@"Icon:"])
                    [dict setObject:value forKey:PackageIconKey];
                else if([key isEqualToString:@"Depiction:"])
                    [dict setObject:value forKey:PackageDepictionKey];
                else if([key isEqualToString:@"Homepage:"])
                    [dict setObject:value forKey:PackageHomepageKey];
                else if([key isEqualToString:@"Website:"])
                    [dict setObject:value forKey:PackageWebsiteKey];
                else
                {
                    if(desc)
                    {
                        if(range.location == 0 && [value length] > 0)
                            desc = [desc stringByAppendingFormat:@" %@", value];
                        else
                        {
                            [dict setObject:desc forKey:PackageDescriptionKey];
                            desc = nil;
                        }
                    }
                }
            }
            else
            {
                if(isInstalled)
                {
                    if(desc)
                    {
                        [dict setObject:desc forKey:PackageDescriptionKey];
                        desc = nil;
                    }

                    [packages addObject:dict];
                    isInstalled = NO;
                }
                
                dict = [NSMutableDictionary dictionary];
            }
        }
    }

    return packages;
}

-(BOOL) installPackage:(NSString*) fileName ignoreDependency:(BOOL) ignoreDependency error:(NSString**) error
{
    [self clearOutput];
    
    NSString* dpkg = nil;
    if(ignoreDependency)
        dpkg = [NSString stringWithFormat:@"dpkg -i --force-depends --log=%s %@", DPKG_OUTPUT, fileName];
    else
        dpkg = [NSString stringWithFormat:@"dpkg -i --log=%s %@", DPKG_OUTPUT, fileName];
    
    setenv("PATH", "/usr/sbin:/usr/bin:/sbin:/bin", 1);
    system([dpkg UTF8String]);

    NSString* status = [self readStatus];
    
    if(status == nil || [status rangeOfString:@"status installed"].length == 0)
    {
        if(status == nil)
            status = @"Failed to read dpkg status";

        *error = status;

        return NO;
    }
    
    return YES;
}

-(BOOL) removePackageWithId:(NSString*) id ignoreDependency:(BOOL) ignoreDependency forceEssential:(BOOL) forceEssential error:(NSString**) error
{
    [self clearOutput];

    NSString* dpkg = [NSString stringWithFormat:@"dpkg -P"];

    if(ignoreDependency)
        dpkg = [dpkg stringByAppendingString:@" --force-depends"];

    if(forceEssential)
        dpkg = [dpkg stringByAppendingString:@" --force-remove-essential"];

    dpkg = [dpkg stringByAppendingFormat:@" --log=%s %@", DPKG_OUTPUT, id];
    
    setenv("PATH", "/usr/sbin:/usr/bin:/sbin:/bin", 1);
    system([dpkg UTF8String]);
    
    NSString* status = [self readStatus];    
    if(status == nil || [status rangeOfString:@"status not-installed"].length == 0)
    {
        if(status == nil)
            status = @"Failed to read dpkg status";
        
        *error = status;
        
        return NO;
    }

    return YES;
}

-(NSString*) infoPlistPathForPackageWithId:(NSString*) id
{
    [self clearOutput];
    
    NSString* dpkg = [NSString stringWithFormat:@"dpkg -L %@ > %s", id, DPKG_OUTPUT];
    setenv("PATH", "/usr/sbin:/usr/bin:/sbin:/bin", 1);
    system([dpkg UTF8String]);
    
    NSArray* lines = [[self readOutput] componentsSeparatedByString:@"\n"];
    NSEnumerator* enumerator = [lines objectEnumerator];
    NSString* line;
    while(line = [enumerator nextObject])
        if([line hasPrefix:@"/Applications"] && [line hasSuffix:@"Info.plist"])
            return line;
    
    return nil;    
}

@end
