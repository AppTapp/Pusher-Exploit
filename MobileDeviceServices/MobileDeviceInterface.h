#ifdef __cplusplus
extern "C" {
#endif
    
#include <CoreFoundation/CoreFoundation.h>
#include <mach/error.h>

/* Error codes */
#define MDERR_APPLE_MOBILE  (err_system(0x3a))
#define MDERR_IPHONE        (err_sub(0))

/* Apple Mobile (AM*) errors */
#define MDERR_OK                ERR_SUCCESS
#define MDERR_SYSCALL           (ERR_MOBILE_DEVICE | 0x01)
#define MDERR_OUT_OF_MEMORY     (ERR_MOBILE_DEVICE | 0x03)
#define MDERR_QUERY_FAILED      (ERR_MOBILE_DEVICE | 0x04) 
#define MDERR_INVALID_ARGUMENT  (ERR_MOBILE_DEVICE | 0x0b)
#define MDERR_DICT_NOT_LOADED   (ERR_MOBILE_DEVICE | 0x25)

/* Apple File Connection (AFC*) errors */
#define MDERR_AFC_OUT_OF_MEMORY 0x03

/* USBMux errors */
#define MDERR_USBMUX_ARG_NULL   0x16
#define MDERR_USBMUX_FAILED     0xffffffff

/* Messages passed to device notification callbacks: passed as part of
 * am_device_notification_callback_info. */
#define ADNCI_MSG_CONNECTED     1
#define ADNCI_MSG_DISCONNECTED  2
#define ADNCI_MSG_UNKNOWN       3

#define AMD_IPHONE_PRODUCT_ID   0x1290
//#define AMD_IPHONE_SERIAL       ""

/* Services, found in /System/Library/Lockdown/Services.plist */
#define AMSVC_AFC                   CFSTR("com.apple.afc")
#define AMSVC_BACKUP                CFSTR("com.apple.mobilebackup")
#define AMSVC_CRASH_REPORT_COPY     CFSTR("com.apple.crashreportcopy")
#define AMSVC_DEBUG_IMAGE_MOUNT     CFSTR("com.apple.mobile.debug_image_mount")
#define AMSVC_NOTIFICATION_PROXY    CFSTR("com.apple.mobile.notification_proxy")
#define AMSVC_PURPLE_TEST           CFSTR("com.apple.purpletestr")
#define AMSVC_SOFTWARE_UPDATE       CFSTR("com.apple.mobile.software_update")
#define AMSVC_SYNC                  CFSTR("com.apple.mobilesync")
#define AMSVC_SCREENSHOT            CFSTR("com.apple.screenshotr")
#define AMSVC_SYSLOG_RELAY          CFSTR("com.apple.syslog_relay")
#define AMSVC_SYSTEM_PROFILER       CFSTR("com.apple.mobile.system_profiler")

typedef unsigned int afc_error_t;
typedef unsigned int usbmux_error_t;

struct am_device_notification_callback_info
{
    struct am_device* dev;  /* 0    device */ 
    unsigned int msg;       /* 4    one of ADNCI_MSG_* */
};

typedef void(*am_device_notification_callback)(struct am_device_notification_callback_info*, void*);

struct am_device
{
    unsigned char unknown0[16]; /* 0 - zero */
    unsigned int device_id;     /* 16 */
    unsigned int product_id;    /* 20 - set to AMD_IPHONE_PRODUCT_ID */
    char* serial;               /* 24 - set to AMD_IPHONE_SERIAL */
    unsigned int unknown1;      /* 28 */
    unsigned char unknown2[4];  /* 32 */
    unsigned int lockdown_connection; /* 36 */
    unsigned char unknown3[8];  /* 40 */
};

struct am_device_notification
{
    unsigned int reserved;
    void* usbmuxListener;
    void* usbmuxRunLoopSource;
    am_device_notification_callback callback;
    void* userinfo;
};

struct afc_connection
{
    unsigned int handle;            /* 0 */
    unsigned int unknown0;          /* 4 */
    unsigned char unknown1;         /* 8 */
    unsigned char padding[3];       /* 9 */
    unsigned int unknown2;          /* 12 */
    unsigned int unknown3;          /* 16 */
    unsigned int unknown4;          /* 20 */
    unsigned int fs_block_size;     /* 24 */
    unsigned int sock_block_size;   /* 28: always 0x3c */
    unsigned int io_timeout;        /* 32: from AFCConnectionOpen, usu. 0 */
    void* afc_lock;                 /* 36 */
    unsigned int context;           /* 40 */
};
    
/* ----------------------------------------------------------------------------
 *   Public routines
 * ------------------------------------------------------------------------- */

/*  Registers a notification with the current run loop. The callback gets
 *  copied into the notification struct, as well as being registered with the
 *  current run loop. dn_unknown3 gets copied into unknown3 in the same.
 *  (Maybe dn_unknown3 is a user info parameter that gets passed as an arg to
 *  the callback?) unused0 and unused1 are both 0 when iTunes calls this.
 *  In iTunes the callback is located from $3db78e-$3dbbaf.
 *
 *  Returns:
 *      MDERR_OK            if successful
 *      MDERR_SYSCALL       if CFRunLoopAddSource() failed
 *      MDERR_OUT_OF_MEMORY if we ran out of memory
 */

extern mach_error_t AMDeviceNotificationSubscribe(am_device_notification_callback
                                           callback, unsigned int unused0, unsigned int unused1, void*
                                           userinfo, struct am_device_notification **notification);

extern mach_error_t AMDeviceNotificationUnsubscribe(struct am_device_notification *notification);
    
/*  Connects to the iPhone. Pass in the am_device structure that the
 *  notification callback will give to you.
 *
 *  Returns:
 *      MDERR_OK                if successfully connected
 *      MDERR_SYSCALL           if setsockopt() failed
 *      MDERR_QUERY_FAILED      if the daemon query failed
 *      MDERR_INVALID_ARGUMENT  if USBMuxConnectByPort returned 0xffffffff
 */

extern mach_error_t AMDeviceConnect(struct am_device *device);
extern mach_error_t AMDeviceDisconnect(struct am_device *device);
    
/*  Calls PairingRecordPath() on the given device, than tests whether the path
 *  which that function returns exists. During the initial connect, the path
 *  returned by that function is '/', and so this returns 1.
 *
 *  Returns:
 *      0   if the path did not exist
 *      1   if it did
 */

extern mach_error_t AMDevicePair(struct am_device *device);
extern mach_error_t AMDeviceUnpair(struct am_device *device);
extern int AMDeviceIsPaired(struct am_device *device);

/*  iTunes calls this function immediately after testing whether the device is
 *  paired. It creates a pairing file and establishes a Lockdown connection.
 *
 *  Returns:
 *      MDERR_OK                if successful
 *      MDERR_INVALID_ARGUMENT  if the supplied device is null
 *      MDERR_DICT_NOT_LOADED   if the load_dict() call failed
 */

extern mach_error_t AMDeviceValidatePairing(struct am_device *device);
extern CFStringRef AMDeviceCopyValue(struct am_device* device, unsigned int unused, CFStringRef value);
    
/*  Creates a Lockdown session and adjusts the device structure appropriately
 *  to indicate that the session has been started. iTunes calls this function
 *  after validating pairing.
 *
 *  Returns:
 *      MDERR_OK                if successful
 *      MDERR_INVALID_ARGUMENT  if the Lockdown conn has not been established
 *      MDERR_DICT_NOT_LOADED   if the load_dict() call failed
 */

extern mach_error_t AMDeviceStartSession(struct am_device *device);

/* Starts a service and returns a handle that can be used in order to further
 * access the service. You should stop the session and disconnect before using
 * the service. iTunes calls this function after starting a session. It starts 
 * the service and the SSL connection. unknown may safely be
 * NULL (it is when iTunes calls this), but if it is not, then it will be
 * filled upon function exit. service_name should be one of the AMSVC_*
 * constants. If the service is AFC (AMSVC_AFC), then the handle is the handle
 * that will be used for further AFC* calls.
 *
 * Returns:
 *      MDERR_OK                if successful
 *      MDERR_SYSCALL           if the setsockopt() call failed
 *      MDERR_INVALID_ARGUMENT  if the Lockdown conn has not been established
 */

extern mach_error_t AMDeviceStartService(struct am_device* device, CFStringRef 
                                  service_name, int* handle, void* unknown);

/* Stops a session. You should do this before accessing services.
 *
 * Returns:
 *      MDERR_OK                if successful
 *      MDERR_INVALID_ARGUMENT  if the Lockdown conn has not been established
 */

extern mach_error_t AMDeviceStopSession(struct am_device* device);

/* Opens an Apple File Connection. You must start the appropriate service
 * first with AMDeviceStartService(). In iTunes, io_timeout is 0.
 *
 * Returns:
 *      MDERR_OK                if successful
 *      MDERR_AFC_OUT_OF_MEMORY if malloc() failed
 */

extern afc_error_t AFCConnectionOpen(int handle, unsigned int io_timeout, struct afc_connection** conn);

/* Closes the given AFC connection. */
extern afc_error_t AFCConnectionClose(struct afc_connection* conn);

/* Pass in a pointer to an afc_device_info structure. It will be filled. */
extern afc_error_t AFCDeviceInfoOpen(struct afc_connection* conn, void** iter);
extern afc_error_t AFCFileInfoOpen(struct afc_connection* conn, const char* path, void** iter);
extern afc_error_t AFCKeyValueRead(void* iter, char** key, char** val);
extern afc_error_t AFCKeyValueClose(void* iter);

/* Opens a directory on the iPhone. Pass in a pointer in dir to be filled in.
 * Note that this normally only accesses the iTunes sandbox/partition as the
 * root, which is /var/root/Media. Pathnames are specified with '/' delimiters
 * as in Unix style.
 *
 * Returns:
 *      MDERR_OK                if successful
 */

extern afc_error_t AFCDirectoryOpen(struct afc_connection* conn, const char* path, void** iter);

/* Acquires the next entry in a directory previously opened with
 * AFCDirectoryOpen(). When dirent is filled with a NULL value, then the end
 * of the directory has been reached. '.' and '..' will be returned as the
 * first two entries in each directory except the root; you may want to skip
 * over them.
 *
 * Returns:
 *      MDERR_OK                if successful, even if no entries remain
 */

extern afc_error_t AFCDirectoryRead(struct afc_connection* conn, void* iter, char** val);
extern afc_error_t AFCDirectoryClose(struct afc_connection* conn, void* iter);
extern afc_error_t AFCDirectoryCreate(struct afc_connection* conn, const char* dirname);
extern afc_error_t AFCRemovePath(struct afc_connection* conn, const char* dirname);
extern afc_error_t AFCRenamePath(struct afc_connection* conn, const char* oldpath, const char* newpath);
extern afc_error_t AFCLinkPath(struct afc_connection* conn, unsigned long long type, const char* oldpath, const char* newpath) WEAK_IMPORT_ATTRIBUTE;

/* mode 2 = read, mode 3 = write; unknown = 0 */
extern afc_error_t AFCFileRefOpen(struct afc_connection* conn, const char* path, unsigned long long mode, unsigned long long* fd);
extern afc_error_t AFCFileRefRead(struct afc_connection* conn, unsigned long long fd, void* buf, unsigned int* len);
extern afc_error_t AFCFileRefWrite(struct afc_connection* conn, unsigned long long fd, const void* buf, unsigned int len);
extern afc_error_t AFCFileRefClose(struct afc_connection* conn, unsigned long long fd);
extern afc_error_t AFCFileRefLock(struct afc_connection* conn, unsigned long long fd);
extern afc_error_t AFCFileRefUnlock(struct afc_connection* conn, unsigned long long fd);

extern mach_error_t AMDPostNotification(int handle, CFStringRef notification, void* userinfo);
extern mach_error_t AMDShutdownNotificationProxy(int handle);
    
#ifdef __cplusplus
}
#endif