#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ftw.h>

#include <sys/stat.h>
#include <sys/utsname.h>

#include <sys/sysctl.h>

#include <CoreFoundation/CoreFoundation.h>

void sig_chld_ignore(int signal)
{
	return;
}

void sig_chld_waitpid(int signal)
{
	while(waitpid(-1, 0, WNOHANG) > 0);
}

void cmd_system_chroot(const char* newRoot, char * argv[])
{
	pid_t fork_pid;
	signal(SIGCHLD, &sig_chld_ignore);
	if((fork_pid = fork()) != 0)
	{
		while(waitpid(fork_pid, NULL, WNOHANG) <= 0)
			usleep(300);
	}
	else
	{
		if(newRoot)
		{
			if(chroot(newRoot) != 0)
			{
				fprintf(stderr, "execute command: chroot failed\n");
				exit(0);
			}
			if(chdir("/") != 0)
			{
				fprintf(stderr, "execute command: chdir failed\n");
				exit(0);
			}
			fflush(stderr);
		}
		
		setenv("PATH", "/tmp", 1);
		
		if(execve(argv[0], argv, NULL) != 0)
		{
			perror("execv");
			fflush(stderr);
			fflush(stdout);
		}
		
		exit(0);
	}

	signal(SIGCHLD, &sig_chld_waitpid);
}

void cmd_system(char * argv[])
{
	cmd_system_chroot(NULL, argv);
}

char* firmwareVersion()
{
	CFPropertyListRef propertyList;
	CFStringRef errorString;
	CFURLRef url;
	CFDataRef resourceData;
	Boolean status;
	SInt32 errorCode;
	char* version;

	url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/System/Library/CoreServices/SystemVersion.plist"), kCFURLPOSIXPathStyle, false);

	status = CFURLCreateDataAndPropertiesFromResource(
			kCFAllocatorDefault,
			url,
			&resourceData,
			NULL,
			NULL,
			&errorCode);

	propertyList = CFPropertyListCreateFromXMLData( kCFAllocatorDefault,
							resourceData,
							kCFPropertyListImmutable,
							&errorString);

	CFRelease(url);
	CFRelease(resourceData);

	version = strdup(CFStringGetCStringPtr(CFDictionaryGetValue(propertyList, CFSTR("ProductVersion")), CFStringGetSystemEncoding()));

	CFRelease(propertyList);

	return version;
}

char* hwModel()
{
	static char hwModel[255] = { 0 };
	static int hwModelInitialized = 0;
	
	if (!hwModelInitialized)
	{
		int mib[2];
		size_t size = sizeof(hwModel);
		
		mib[0] = CTL_HW;
		mib[1] = HW_MACHINE;
		
		sysctl(mib, 2, hwModel, &size, NULL, 0);
		
		hwModelInitialized = 1;
	}
	
	return hwModel;
}

int is2G()
{
	char* model = hwModel();
	
	return (strcmp("iPhone1,1", model) == 0);
}

int is3G()
{
	char* model = hwModel();
	
	return (strcmp("iPhone1,2", model) == 0);
}

int fileExists(const char* fileName)
{
	struct stat status;
	if(stat(fileName, &status) == 0)
		return 1;
	else
		return 0;
}

void fileCopy(const char* orig, const char* dest)
{
        size_t read;
        char buffer[4096];
        FILE* fOrig;
        FILE* fDest;

	fOrig = fopen(orig, "rb");

	if (fOrig != NULL)
	{
		fDest = fopen(dest, "wb");

	        while (!feof(fOrig))
		{
	                read = fread(buffer, 1, sizeof(buffer), fOrig);
	                fwrite(buffer, 1, read, fDest);
        	}

	        fclose(fDest);
        	fclose(fOrig);
	}
}

#pragma mark -

#if defined(SECURE_PUSHER)
void installAppContainer(CFStringRef inContainerName, CFStringRef inAppName, CFStringRef inSignerIdentity)
{
	CFStringRef containerPath = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR("/var/mobile/Applications/%@"), inContainerName);
	CFStringRef appBundlePath = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR("%@/%@"), containerPath, inAppName);
	CFURLRef appBundleURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, appBundlePath, kCFURLPOSIXPathStyle, true);
	
	printf("App wrapper sandboxer: installing...\n"); fflush(stdout);
	CFShow(appBundlePath);
	
	if (!containerPath || !appBundlePath)
		return;
	
	// Create needed symlinks
	{
		char cp[1024];
		
		if (CFStringGetCString(containerPath, cp, sizeof(cp), kCFStringEncodingUTF8))
		{
			char symlinkPath[2048];
			
			strcpy(symlinkPath, cp);
			strcat(symlinkPath, "/Library/Preferences/.GlobalPreferences.plist");
			
			printf("App wrapper sandboxer: linking %s...\n", symlinkPath); fflush(stdout);
			
			symlink("/private/var/mobile/Library/Preferences/.GlobalPreferences.plist", symlinkPath);
		}
	}
	
	CFBundleRef appBundle = CFBundleCreate(kCFAllocatorDefault, appBundleURL);
	if (!appBundle)
	{
		printf("App wrapper sandboxer: cannot create a bundle for the application.\n"); fflush(stdout);
		return;
	}
	
	CFDictionaryRef infoDict = CFBundleGetInfoDictionary(appBundle);
	CFMutableDictionaryRef newInfoDict = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, infoDict);
	
	if (!newInfoDict)
	{
		printf("App wrapper sandboxer: cannot create a bundle info dictionary entry for the application.\n"); fflush(stdout);
		return;
		
	}
	
	CFDictionaryRemoveValue(newInfoDict, CFSTR("CFBundleInfoPlistURL"));
	
	CFDictionarySetValue(newInfoDict, CFSTR("ApplicationType"), CFSTR("User"));
	CFDictionarySetValue(newInfoDict, CFSTR("Container"), containerPath);
	CFDictionarySetValue(newInfoDict, CFSTR("Path"), appBundlePath);
	CFDictionarySetValue(newInfoDict, CFSTR("ProfileValidated"), kCFBooleanTrue);
	CFDictionarySetValue(newInfoDict, CFSTR("SignerIdentity"), inSignerIdentity);
	
	CFStringRef sandboxProfile = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR("%@.sb"), containerPath);
	if (sandboxProfile)
	{
		CFDictionarySetValue(newInfoDict, CFSTR("SandboxProfile"), sandboxProfile);
		CFRelease(sandboxProfile);
	}
	
	// Create environment variables entry
	CFMutableDictionaryRef envVars = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
	if (envVars)
	{
		CFDictionarySetValue(envVars, CFSTR("CFFIXED_USER_HOME"), containerPath);
		CFDictionarySetValue(envVars, CFSTR("HOME"), containerPath);
		CFStringRef tmpDir = CFStringCreateWithFormat(kCFAllocatorDefault, NULL, CFSTR("%@/tmp"), containerPath);
		if (tmpDir)
		{
			CFDictionarySetValue(envVars, CFSTR("TMPDIR"), tmpDir);
			CFRelease(tmpDir);
		}
		
		CFDictionarySetValue(newInfoDict, CFSTR("EnvironmentVariables"), envVars);
		
		CFRelease(envVars);
	}
	
	// Now fetch the mobile installation cache and inject the app into it
	{
		CFMutableDictionaryRef propertyList;
		CFStringRef errorString = NULL;
		CFURLRef url;
		CFDataRef resourceData = NULL;
		Boolean status;
		SInt32 errorCode = 0;

		url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/var/mobile/Library/Caches/com.apple.mobile.installation.plist"), kCFURLPOSIXPathStyle, false);

		status = CFURLCreateDataAndPropertiesFromResource(
				kCFAllocatorDefault,
				url,
				&resourceData,
				NULL,
				NULL,
				&errorCode);

		if (resourceData)
		{
			propertyList = (CFMutableDictionaryRef)CFPropertyListCreateFromXMLData( kCFAllocatorDefault,
								resourceData,
								kCFPropertyListMutableContainersAndLeaves,
								&errorString);
			
			if (!propertyList)
				CFShow(errorString);
				
			if (propertyList)
			{
/* 20081003 CYRIL++, с днем рождения, ёпт */
				char * sysver = firmwareVersion();
				if (sysver == NULL)
					sysver = "2.1";	//	sentinel
				
				CFTypeRef userSpace = (CFTypeRef)CFDictionaryGetValue(propertyList, CFSTR("User"));
				
				if (!userSpace)
				{
					if (strncmp(sysver, "2.0", 3) == 0)
						userSpace = (CFTypeRef)CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
					else
						userSpace = (CFTypeRef)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
				}
				else
					CFRetain(userSpace);
					
				if (strncmp(sysver, "2.0", 3) == 0)
					CFArrayAppendValue((CFMutableArrayRef)userSpace, newInfoDict);
				else
					CFDictionarySetValue((CFMutableDictionaryRef)userSpace, CFBundleGetIdentifier(appBundle), newInfoDict);
/* 20081003 CYRIL-- */

				CFDictionarySetValue(propertyList, CFSTR("User"), userSpace);

				CFRelease(userSpace);
				
//				printf("Saving back mobile installation: \n"); fflush(stdout);
//				CFShow(propertyList);
				
				CFDataRef xmlData = CFPropertyListCreateXMLData(kCFAllocatorDefault, propertyList);
				if (xmlData)
				{
					FILE* out = fopen("/var/mobile/Library/Caches/com.apple.mobile.installation.plist", "w");
					if (out)
					{
					//	printf("Saving back mobile installation cache (%u bytes)\n", CFDataGetLength(xmlData)); fflush(stdout);
						fwrite(CFDataGetBytePtr(xmlData), 1, CFDataGetLength(xmlData), out);
						fclose(out);
					}
					else
					{
						printf("Opening /var/mobile/Library/Caches/com.apple.mobile.installation.plist failed: %d (%s)\n", errno, strerror(errno)); fflush(stdout);
					}
					
					CFRelease(xmlData);
				}
			}
		}
		
		CFRelease(url);
		CFRelease(resourceData);

		CFRelease(propertyList);
		
	}
	
	CFRelease(containerPath);
	CFRelease(appBundlePath);
	
	// Update composite trust
	{
		CFMutableDictionaryRef propertyList;
		CFStringRef errorString = NULL;
		CFURLRef url;
		CFDataRef resourceData = NULL;
		Boolean status;
		SInt32 errorCode = 0;

		url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/var/mobile/Library/Caches/com.apple.mobile.installation.composite_trust.plist"), kCFURLPOSIXPathStyle, false);

		status = CFURLCreateDataAndPropertiesFromResource(
				kCFAllocatorDefault,
				url,
				&resourceData,
				NULL,
				NULL,
				&errorCode);

		if (resourceData)
		{
			propertyList = (CFMutableDictionaryRef)CFPropertyListCreateFromXMLData( kCFAllocatorDefault,
								resourceData,
								kCFPropertyListMutableContainersAndLeaves,
								&errorString);
			
			if (!propertyList)
				CFShow(errorString);
				
			if (propertyList)
			{
				CFDictionarySetValue(propertyList, inSignerIdentity, kCFBooleanTrue);
				
				CFDataRef xmlData = CFPropertyListCreateXMLData(kCFAllocatorDefault, propertyList);
				if (xmlData)
				{
					FILE* out = fopen("/var/mobile/Library/Caches/com.apple.mobile.installation.composite_trust.plist", "w");
					if (out)
					{
					//	printf("Saving back mobile installation cache (%u bytes)\n", CFDataGetLength(xmlData)); fflush(stdout);
						fwrite(CFDataGetBytePtr(xmlData), 1, CFDataGetLength(xmlData), out);
						fclose(out);
					}
					else
					{
						printf("Opening /var/mobile/Library/Caches/com.apple.mobile.installation.composite_trust.plist failed: %d (%s)\n", errno, strerror(errno)); fflush(stdout);
					}
					
					CFRelease(xmlData);
				}
				
			}
		}
	}
}
#endif

void installAFC2()
{
	// "/mnt/System/Library/Lockdown/Services.plist"
	CFMutableDictionaryRef propertyList;
	CFStringRef errorString = NULL;
	CFURLRef url;
	CFDataRef resourceData = NULL;
	Boolean status;
	SInt32 errorCode = 0;

	url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/mnt/System/Library/Lockdown/Services.plist"), kCFURLPOSIXPathStyle, false);

	status = CFURLCreateDataAndPropertiesFromResource(
			kCFAllocatorDefault,
			url,
			&resourceData,
			NULL,
			NULL,
			&errorCode);

	if (resourceData)
	{
		propertyList = (CFMutableDictionaryRef)CFPropertyListCreateFromXMLData( kCFAllocatorDefault,
							resourceData,
							kCFPropertyListMutableContainersAndLeaves,
							&errorString);
		
		if (!propertyList)
			CFShow(errorString);
			
		if (propertyList)
		{
#if defined(SECURE_PUSHER)
			if (CFDictionaryGetValue(propertyList, CFSTR("com.apple.afc2")))
			{
				printf("Not installing afc2 as it's already installed...\n"); fflush(stdout);
				CFRelease(resourceData);
				CFRelease(url);
				CFRelease(propertyList);
				return;
			}
#endif
			
			CFMutableDictionaryRef newEntry = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
			if (newEntry)
			{
				CFDictionarySetValue(newEntry, CFSTR("AllowUnactivatedService"), kCFBooleanTrue);
				CFDictionarySetValue(newEntry, CFSTR("Label"), CFSTR("com.apple.afc2"));
				
				CFMutableArrayRef argsArray = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
				if (argsArray)
				{
					CFArrayAppendValue(argsArray, CFSTR("/usr/libexec/afcd"));
					CFArrayAppendValue(argsArray, CFSTR("--lockdown"));
					CFArrayAppendValue(argsArray, CFSTR("-d"));
#if defined(SECURE_PUSHER)
					CFArrayAppendValue(argsArray, CFSTR("/private/var"));
#else
					CFArrayAppendValue(argsArray, CFSTR("/"));
#endif					
					CFDictionarySetValue(newEntry, CFSTR("ProgramArguments"), argsArray);
					CFRelease(argsArray);
					
					CFDictionarySetValue(propertyList, CFSTR("com.apple.afc2"), newEntry);
					
					// save out
					CFDataRef xmlData = CFPropertyListCreateXMLData(kCFAllocatorDefault, propertyList);
					if (xmlData)
					{
						FILE* out = fopen("/mnt/System/Library/Lockdown/Services.plist", "w");
						if (out)
						{
							printf("Saving back Services.plist (%u bytes)\n", CFDataGetLength(xmlData)); fflush(stdout);
							fwrite(CFDataGetBytePtr(xmlData), 1, CFDataGetLength(xmlData), out);
							fclose(out);
						}
						else
						{
							printf("Opening /System/Library/Lockdown/Services.plist failed: %d (%s)\n", errno, strerror(errno)); fflush(stdout);
						}

						CFRelease(xmlData);
					}
				}
				
				CFRelease(newEntry);
			}
			
			CFRelease(propertyList);
		}
		
		CFRelease(resourceData);
	}
	
	CFRelease(url);
}

#if defined(SECURE_PUSHER)
void installInstallerd()
{
	// "/mnt/System/Library/Lockdown/Services.plist"
	CFMutableDictionaryRef propertyList;
	CFStringRef errorString = NULL;
	CFURLRef url;
	CFDataRef resourceData = NULL;
	Boolean status;
	SInt32 errorCode = 0;

	url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/mnt/System/Library/Lockdown/Services.plist"), kCFURLPOSIXPathStyle, false);

	status = CFURLCreateDataAndPropertiesFromResource(
			kCFAllocatorDefault,
			url,
			&resourceData,
			NULL,
			NULL,
			&errorCode);

	if (resourceData)
	{
		propertyList = (CFMutableDictionaryRef)CFPropertyListCreateFromXMLData( kCFAllocatorDefault,
							resourceData,
							kCFPropertyListMutableContainersAndLeaves,
							&errorString);
		
		if (!propertyList)
			CFShow(errorString);
			
		if (propertyList)
		{
			if (CFDictionaryGetValue(propertyList, CFSTR("com.ripdev.installerd")))
			{
				printf("Not installing installerd as it's already installed...\n"); fflush(stdout);
				CFRelease(resourceData);
				CFRelease(url);
				CFRelease(propertyList);
				return;
			}
			
			CFMutableDictionaryRef newEntry = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
			if (newEntry)
			{
				CFDictionarySetValue(newEntry, CFSTR("AllowUnactivatedService"), kCFBooleanTrue);
				CFDictionarySetValue(newEntry, CFSTR("Label"), CFSTR("com.ripdev.installerd"));
				
				CFMutableArrayRef argsArray = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
				if (argsArray)
				{
					CFArrayAppendValue(argsArray, CFSTR("/usr/libexec/installerd"));
					
					CFDictionarySetValue(newEntry, CFSTR("ProgramArguments"), argsArray);
					CFRelease(argsArray);
					
					CFDictionarySetValue(propertyList, CFSTR("com.ripdev.installerd"), newEntry);
					
					// save out
					CFDataRef xmlData = CFPropertyListCreateXMLData(kCFAllocatorDefault, propertyList);
					if (xmlData)
					{
						FILE* out = fopen("/mnt/System/Library/Lockdown/Services.plist", "w");
						if (out)
						{
							printf("Saving back Services.plist (%u bytes)\n", CFDataGetLength(xmlData)); fflush(stdout);
							fwrite(CFDataGetBytePtr(xmlData), 1, CFDataGetLength(xmlData), out);
							fclose(out);
						}
						else
						{
							printf("Opening /System/Library/Lockdown/Services.plist failed: %d (%s)\n", errno, strerror(errno)); fflush(stdout);
						}

						CFRelease(xmlData);
					}
				}
				
				CFRelease(newEntry);
			}
			
			CFRelease(propertyList);
		}
		
		CFRelease(resourceData);
	}
	
	CFRelease(url);
}

void installInstaller()
{
	CFStringRef containerPath = CFSTR("/Applications/Installer.app");
	CFStringRef appBundlePath = CFSTR("/mnt/Applications/Installer.app");
	CFURLRef appBundleURL = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, appBundlePath, kCFURLPOSIXPathStyle, true);
	
	printf("Installer.app: installing...\n"); fflush(stdout);
	
	if (!containerPath || !appBundlePath)
		return;
	
	CFBundleRef appBundle = CFBundleCreate(kCFAllocatorDefault, appBundleURL);
	if (!appBundle)
	{
		printf("App wrapper sandboxer: cannot create a bundle for the application.\n"); fflush(stdout);
		return;
	}
	
	CFDictionaryRef infoDict = CFBundleGetInfoDictionary(appBundle);
	CFMutableDictionaryRef newInfoDict = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, infoDict);
	
	if (!newInfoDict)
	{
		printf("App wrapper sandboxer: cannot create a bundle info dictionary entry for the application.\n"); fflush(stdout);
		return;
		
	}
	
	if (chown("/mnt/Applications/Installer.app/Scythe", 0, 0))
	{
		printf("chown of Installer.app/Scythe failed: %d (%s)\n", errno, strerror(errno)); fflush(stdout);
	}
	
	if (chown("/mnt/Applications/Installer.app/Installer", 0, 0))
	{
		printf("chown of Installer.app/Installer failed: %d (%s)\n", errno, strerror(errno)); fflush(stdout);
	}
	
	if (chmod("/mnt/Applications/Installer.app/Installer", (S_ISUID | S_ISGID | S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)))
	{
		printf("chmod of Installer.app/Installer failed: %d (%s)\n", errno, strerror(errno)); fflush(stdout);
	}
	
	struct stat st;
	
	if (stat("/mnt/Applications/Installer.app/Installer", &st) == 0)
	{
		printf("Installer.app permissions: %o (%d:%d)\n", st.st_mode, st.st_uid, st.st_gid); fflush(stdout);
	}
	
	CFDictionaryRemoveValue(newInfoDict, CFSTR("CFBundleInfoPlistURL"));
	
	CFDictionarySetValue(newInfoDict, CFSTR("ApplicationType"), CFSTR("System"));
	CFDictionarySetValue(newInfoDict, CFSTR("Path"), containerPath);
	
	// Now fetch the mobile installation cache and inject the app into it
	{
		CFMutableDictionaryRef propertyList;
		CFStringRef errorString = NULL;
		CFURLRef url;
		CFDataRef resourceData = NULL;
		Boolean status;
		SInt32 errorCode = 0;

		url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/var/mobile/Library/Caches/com.apple.mobile.installation.plist"), kCFURLPOSIXPathStyle, false);

		status = CFURLCreateDataAndPropertiesFromResource(
				kCFAllocatorDefault,
				url,
				&resourceData,
				NULL,
				NULL,
				&errorCode);

		if (resourceData)
		{
			propertyList = (CFMutableDictionaryRef)CFPropertyListCreateFromXMLData( kCFAllocatorDefault,
								resourceData,
								kCFPropertyListMutableContainersAndLeaves,
								&errorString);
			
			if (!propertyList)
				CFShow(errorString);
				
			if (propertyList)
			{
/* 20081003 CYRIL++, с днем рождения, ёпт */
				char * sysver = firmwareVersion();
				if (sysver == NULL)
					sysver = "2.1";	//	sentinel
				
				CFTypeRef userSpace = (CFTypeRef)CFDictionaryGetValue(propertyList, CFSTR("System"));
				
				if (!userSpace)
				{
					if (strncmp(sysver, "2.0", 3) == 0)
						userSpace = (CFTypeRef)CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
					else
						userSpace = (CFTypeRef)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
				}
				else
					CFRetain(userSpace);
					
				if (strncmp(sysver, "2.0", 3) == 0)
					CFArrayAppendValue((CFMutableArrayRef)userSpace, newInfoDict);
				else
					CFDictionarySetValue((CFMutableDictionaryRef)userSpace, CFBundleGetIdentifier(appBundle), newInfoDict);
/* 20081003 CYRIL-- */

				CFDictionarySetValue(propertyList, CFSTR("System"), userSpace);

				CFRelease(userSpace);
				
//				printf("Saving back mobile installation: \n"); fflush(stdout);
//				CFShow(propertyList);
				
				CFDataRef xmlData = CFPropertyListCreateXMLData(kCFAllocatorDefault, propertyList);
				if (xmlData)
				{
					FILE* out = fopen("/var/mobile/Library/Caches/com.apple.mobile.installation.plist", "w");
					if (out)
					{
					//	printf("Saving back mobile installation cache (%u bytes)\n", CFDataGetLength(xmlData)); fflush(stdout);
						fwrite(CFDataGetBytePtr(xmlData), 1, CFDataGetLength(xmlData), out);
						fclose(out);
					}
					else
					{
						printf("Opening /var/mobile/Library/Caches/com.apple.mobile.installation.plist failed: %d (%s)\n", errno, strerror(errno)); fflush(stdout);
					}
					
					CFRelease(xmlData);
				}
			}
		}
		
		CFRelease(url);
		CFRelease(resourceData);

		CFRelease(propertyList);
		
	}
}
#endif

#if defined(SECURE_PUSHER)
void stash(char* directory, char* stashName)
{
	struct stat st;
	
	char mntDir[1024];
	
	strcpy(mntDir, "/mnt/");
	strcat(mntDir, directory);
	
	if (lstat(mntDir, &st))
	{
		// Create the directory. This will not work for recursive dirs, but we don't care.
		if (mkdir(mntDir, 0755) != 0)
		{
			printf("Cannot mkdir/lstat %s for stashing: %d (%s)\n", mntDir, errno, strerror(errno)); fflush(stdout);
			return;
		}
	}
	
	if ((st.st_mode & S_IFMT) == S_IFLNK)
	{
		printf("Stashing: %s is already not a directory; skipping.\n", directory); fflush(stdout);
		return;
	}
	
	// if we got here, we're ready to move. create a new directory for the stash.
	if (stat("/var/stash", &st))
		mkdir("/var/stash", 0755);
	
	char stashDir[1024];
	
	strcpy(stashDir, "/var/stash/");
	strcat(stashDir, stashName);
	
	printf("Stashing %s -> %s\n", directory, stashDir); fflush(stdout);
		
	// it's time to mooove
	cmd_system_chroot("/mnt", (char*[]){"/tmp/mv", directory, stashDir, (char*) 0});
	symlink(stashDir, mntDir);
}
#endif

#pragma mark -

int recursiveDelete(const char *path, const struct stat *status, int flag, struct FTW *buf)
{
	switch (flag) {
	 case FTW_DNR:
	 case FTW_DP:
	  rmdir(path);
	  break;
	 case FTW_F:
	 case FTW_NS:
	 case FTW_SL:
	 case FTW_SLN:
	  unlink(path);
	  break;
	}

	return 0;
}

void deleteDir(const char *path) {
	nftw(path, recursiveDelete, 5, FTW_DEPTH);
}

#if defined(SECURE_PUSHER)
extern int installBundle(const char* path, const struct stat *sb, int typeFlag);
void activate() {
	printf("Activate: replacing factory activation certificate...\n"); fflush(stdout);
	fileCopy("/iPhoneActivation.pem", "/System/Library/Lockdown/FactoryActivation.pem");

	printf("Activate: deleting conflicting activation records...\n"); fflush(stdout);
	deleteDir("/var/root/Library/Lockdown/activation_records");

	printf("Activate: deleting conflicting pair records...\n"); fflush(stdout);
	deleteDir("/var/root/Library/Lockdown/pair_records");

	printf("Activate: creating activation records directory (if necessary)...\n"); fflush(stdout);
	mkdir("/var/root/Library/Lockdown/activation_records", 0755);
	chown("/var/root/Library/Lockdown/activation_records", 0, 0);

	printf("Activate: expanding YouTube files...\n"); fflush(stdout);
	installBundle("/youtube.tar.gz", NULL, FTW_F);	

	printf("Activate: running iASign...\n"); fflush(stdout);
	cmd_system((char* []){"/iASign.iphone", "--autolocalgenerate", "/iPhoneActivation_private.pem",
	  "/var/root/Library/Lockdown/activation_records/wildcard_record.plist", NULL});

	printf("Activate: running iAYoutube...\n"); fflush(stdout);
	cmd_system((char* []){"/iAYoutube.iphone", "--injectcert", NULL});
}

char* activationState() {
	CFPropertyListRef propertyList;
	CFStringRef errorString;
	CFURLRef url;
	CFDataRef resourceData;
	Boolean status;
	SInt32 errorCode;
	char* activationState = "Unactivated";

	url = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/var/root/Library/Lockdown/data_ark.plist"), kCFURLPOSIXPathStyle, false);

	status = CFURLCreateDataAndPropertiesFromResource(
	              kCFAllocatorDefault,
	              url,
	              &resourceData,
	              NULL,
	              NULL,
	              &errorCode);

	if (resourceData)
	{
		propertyList = CFPropertyListCreateFromXMLData( kCFAllocatorDefault,
		              resourceData,
		              kCFPropertyListImmutable,
		              &errorString);

		CFRelease(url);
		CFRelease(resourceData);

		if ( CFDictionaryContainsKey(propertyList, CFSTR("com.apple.mobile.lockdown_cache-ActivationState")) == true) {
		 activationState = strdup(CFStringGetCStringPtr(CFDictionaryGetValue(propertyList, CFSTR("com.apple.mobile.lockdown_cache-ActivationState")),  CFStringGetSystemEncoding()));
		}
 
		CFRelease(propertyList);
	}

	return activationState;
}
#endif

#pragma mark -

/*
Package: dpkg
Essential: yes
Status: install ok installed
Priority: required
Section: Packaging
Installed-Size: 2604
Maintainer: Ripdev <support@ripdev.com>
Architecture: iphoneos-arm
Version: 99.99.99
Depends: bash, bzip2, coreutils, diffutils, findutils, gzip, ncurses, tar
Description: package maintainance tools from Debian
Name: Debian Packager

Package: firmware
Essential: yes
Status: install ok installed
Priority: required
Section: System
Installed-Size: 0
Maintainer: Ripdev <support@ripdev.com>
Architecture: iphoneos-arm
Version: %s
Description: iPhome OS
Name: iPhone Firmware
*/

#if !defined(SECURE_PUSHER) || defined(TEST)
void tweakDpkgInstall_(char* filename, char* fullInfo, char* packageTag, char* version);

#if defined(TEST)
	#define FIRMWARE_LIST_FILE "firmware.list"
	#define DPKG_LIST_FILE "dpkg.list"
#else
	#define FIRMWARE_LIST_FILE "/mnt/var/lib/dpkg/info/firmware.list"
	#define DPKG_LIST_FILE "/mnt/var/lib/dpkg/info/dpkg.list"
#endif

void tweakDpkgInstall(char* version)
{
	char* fullStatusInfo = "Package: dpkg\nEssential: yes\nStatus: install ok installed\nPriority: required\nSection: Packaging\nInstalled-Size: 2604\nMaintainer: Ripdev <support@ripdev.com>\nArchitecture: iphoneos-arm\nVersion: 9.99.99\nDepends: bash, bzip2, coreutils, diffutils, findutils, gzip, ncurses, tar\nDescription: package maintainance tools from Debian (Cleaner Than Saurik's Edition)\nName: Debian Packager\n\n";
	char* fullAvailInfo = "Package: dpkg\nEssential: yes\nPriority: required\nSection: Packaging\nInstalled-Size: 2604\nMaintainer: Ripdev <support@ripdev.com>\nArchitecture: iphoneos-arm\nVersion: 9.99.99\nDepends: bash, bzip2, coreutils, diffutils, findutils, gzip, ncurses, tar\nDescription: package maintainance tools from Debian (Cleaner Than Saurik's Edition)\nName: Debian Packager\n\n";
	
	char* firmwareStatusFormat = "Package: firmware\nEssential: yes\nStatus: install ok installed\nPriority: required\nSection: System\nInstalled-Size: 0\nMaintainer: Ripdev <support@ripdev.com>\nArchitecture: iphoneos-arm\nVersion: %s\nDescription: iPhone OS\nName: iPhone Firmware\n\n";
	char* firmwareAvailFormat = "Package: firmware\nEssential: yes\nPriority: required\nSection: System\nInstalled-Size: 0\nMaintainer: Ripdev <support@ripdev.com>\nArchitecture: iphoneos-arm\nVersion: %s\nDescription: iPhone OS\nName: iPhone Firmware\n\n";
	
	char buffer[8192];
	char versionBuffer[255];
	sprintf(versionBuffer, "Version: %s\n", version);

#if defined(TEST)
	tweakDpkgInstall_("status", fullStatusInfo, "Package: dpkg", "Version: 9.99.99\n");
	tweakDpkgInstall_("available", fullAvailInfo, "Package: dpkg", "Version: 9.99.99\n");
	
	sprintf(buffer, firmwareStatusFormat, version);
	tweakDpkgInstall_("status", buffer, "Package: firmware", versionBuffer);
	
	sprintf(buffer, firmwareAvailFormat, version);
	tweakDpkgInstall_("available", buffer, "Package: firmware", versionBuffer);
	
#else
	tweakDpkgInstall_("/mnt/var/lib/dpkg/status", fullStatusInfo, "Package: dpkg", "Version: 9.99.99\n");
	tweakDpkgInstall_("/mnt/var/lib/dpkg/available", fullAvailInfo, "Package: dpkg", "Version: 9.99.99\n");

	sprintf(buffer, firmwareStatusFormat, version);
	tweakDpkgInstall_("/mnt/var/lib/dpkg/status", buffer, "Package: firmware", versionBuffer);
	
	sprintf(buffer, firmwareAvailFormat, version);
	tweakDpkgInstall_("/mnt/var/lib/dpkg/available", buffer, "Package: firmware", versionBuffer);
#endif

	struct stat st;
	
	if (stat(FIRMWARE_LIST_FILE, &st))
	{
		FILE* firmwareFile = fopen(FIRMWARE_LIST_FILE, "w");
		
		if (firmwareFile)
		{
			fprintf(firmwareFile, "/.\n");
			fclose(firmwareFile);
		}
	}
	
	if (stat(DPKG_LIST_FILE, &st))
	{
		FILE* firmwareFile = fopen(DPKG_LIST_FILE, "w");
		
		if (firmwareFile)
		{
			fprintf(firmwareFile, "/.\n/usr\n/usr/bin\n/usr/bin/dpkg\n/usr/bin/dpkg-deb\n/usr/bin/dpkg-query\n/usr/bin/dpkg-split\n/usr/sbin\n/usr/sbin/install-info\n/var\n/var/lib\n/var/lib/dpkg\n/var/lib/dpkg/alternatives\n/var/lib/dpkg/info\n/var/lib/dpkg/parts\n/var/lib/dpkg/updates\n");
			fclose(firmwareFile);
		}
	}
}

void tweakDpkgInstall_(char* filename, char* fullInfo, char* packageTag, char* version)
{
	static char* maintainer = "Maintainer: Ripdev <support@ripdev.com>\n";
	static char* maintainerTag = "Maintainer: ";
	static char* versionTag = "Version: ";
	
	FILE* in;
	FILE* out;
	
#if defined(TEST)
	char ooo[255];
	
	sprintf(ooo, "temp-%d", strlen(filename));
	
	in = fopen(filename, "r");
	out = fopen(ooo, "w");
#else
	in = fopen(filename, "r");
	out = fopen("/mnt/tmp/xxx", "w");
#endif

	if (!in && out)
	{
		// spool a predefined package info and bail out
		fwrite(fullInfo, sizeof(char), strlen(fullInfo), out);
		fclose(out);
		
		fileCopy(
		#if defined(TEST)
				ooo,
		#else
				"/mnt/tmp/xxx",
		#endif
				filename);

		#if defined(TEST)
			unlink(ooo);
		#else
			unlink("/mnt/tmp/xxx");
		#endif
		return;
	}
	
	if (!out)
		return;
	
	char buffer[8192];
	int in_dpkg_chunk = 0;
	int found = 0;
	
	while (!feof(in))
	{
		if (fgets(buffer, sizeof(buffer), in) != NULL)
		{
			if (!strncmp(buffer, packageTag, strlen(packageTag)))
			{
				in_dpkg_chunk = 1;
				found = 1;
			}
			
			if (in_dpkg_chunk)
			{
				if (buffer[0] == '\n')
					in_dpkg_chunk = 0;
				
				if (!strncmp(buffer, maintainerTag, strlen(maintainerTag)))
				{
					fwrite(maintainer, sizeof(char), strlen(maintainer), out);
					continue;
				}
				
				if (!strncmp(buffer, versionTag, strlen(versionTag)))
				{
					fwrite(version, sizeof(char), strlen(version), out);
					continue;
				}
			}
			
			fwrite(buffer, sizeof(char), strlen(buffer), out);
		}
	}
	
	if (!found)
	{
		fwrite(fullInfo, sizeof(char), strlen(fullInfo), out);
	}
	
	fclose(in);
	fclose(out);
	
	fileCopy(
#if defined(TEST)
		ooo,
#else
		"/mnt/tmp/xxx",
#endif
		filename);
		
#if defined(TEST)
	unlink(ooo);
#else
	unlink("/mnt/tmp/xxx");
#endif
}
#endif