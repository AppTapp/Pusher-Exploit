/*!
 @source RamdiskBuilder.m
 @project Pusher
 @author Alexander Maksimenko
 @copyright Copyright (c) 2009 Ripdev. All rights reserved.
 */

#import "RootFSDecrypt.h"
#import "Firmware.h"
#import "OpenSSLHelper.h"
#import "RamdiskBuilder.h"

@implementation RamdiskBuilder

-(id) init
{
    self = [super init];

    _firmware = nil;
    _secureTask = [[SecureTask alloc] init];

    return self;
}

-(void) dealloc
{
    [_firmware release];
    [_secureTask release];

    [super dealloc];
}

-(void) threadTask:(NSDictionary*) dict
{
    _abortBuilding = NO;

    [self sendMessage:BuilderStatusMessage withData:[NSArchiver archivedDataWithRootObject:[NSNumber numberWithInt:BSStart]]];

    if([[InstanceManager firmware] unzipTo:SystemTempDir] && [self buildRamdisk])
        [self sendMessage:BuilderStatusMessage withData:[NSArchiver archivedDataWithRootObject:[NSNumber numberWithInt:BSSuccess]]];
    else
        [self sendMessage:BuilderStatusMessage withData:[NSArchiver archivedDataWithRootObject:[NSNumber numberWithInt:BSFailed]]];
}

-(BOOL) buildRamdisk
{
    if(![self patchFirmware] || _abortBuilding)
        return NO;

    if(![self copyRamdisk] || _abortBuilding)
        return NO;

    return YES;
}

-(BOOL) copyRamdisk
{
// Copy ramdisk

    NSFileManager* fileManager = [NSFileManager defaultManager];

    NSString* ramdisk = [SystemTempDir stringByAppendingPathComponent:[[InstanceManager firmware] restoreRamdiskFile]];
    NSString* ramdiskResource = [InstanceManager ramdiskPath];
    
    [fileManager removeFileAtPath:ramdisk handler:nil];
        
    if(![fileManager copyPath:ramdiskResource toPath:ramdisk handler:nil])
    {
        Log(@"Failed to copy pusher ramdisk to temp location");
        return NO;
    }

    [OpenSSLHelper updateFile:ramdisk with:Decrypt];
    
    return YES;
}

-(BOOL) rebuildRamdisk
{
// Copy ramdisk

    NSFileManager* fileManager = [NSFileManager defaultManager];

    NSString* ramdisk = [SystemTempDir stringByAppendingPathComponent:CustomRamdisk];
    NSString* ramdiskResource = [InstanceManager ramdiskPath];
    
    if(![fileManager copyPath:ramdiskResource toPath:ramdisk handler:nil])
    {
        Log(@"Failed to copy pusher ramdisk to temp location");
        return NO;
    }

    if(![[InstanceManager firmware] makeRamdisk:rtRestore from:ramdisk encrypt:NO])
    {
        Log(@"Failed to inject pusher ramdisk to restore ramdisk");
        return NO;
    }

	if(![fileManager removeFileAtPath:ramdisk handler:nil])
	{
        Log(@"Failed to remove temp copy of pusher ramdisk");
        return NO;
    }
    
    return YES;
}

-(BOOL) patchFirmware
{
    NSDictionary* patches = [[InstanceManager firmware] firmwarePatches];
    NSArray* keys = [patches allKeys];
    unsigned int keysCount = [keys count];
    unsigned int i;

    for(i = 0;i < keysCount;i++)
    {
        NSString* module = [keys objectAtIndex:i];

        if([module isEqualToString:FWWTF2Key] || [module isEqualToString:FWIBSSKey] || [module isEqualToString:FWKernelCacheKey])
        {
            if([[patches objectForKey:module] objectForKey:PatchKey] != nil)
            {
                NSDictionary* dict = [patches objectForKey:module];
                int type = [[dict objectForKey:TypeFlagKey] intValue];
                NSString* file = [SystemTempDir stringByAppendingPathComponent:[dict objectForKey:FileKey]];
                NSString* patch = [[InstanceManager firmware] bundlePath];
                NSString* key = [dict objectForKey:KeyKey];
                NSString* iv = [dict objectForKey:IVKey];    
                BOOL exploit = NO;
                
                if([module isEqualToString:FWWTF2Key])
                    exploit = YES;
                    
                patch = [patch stringByAppendingPathComponent:[dict objectForKey:PatchKey]];
                
                if(![[InstanceManager firmware] patchFirmwareModule:file ofType:type withPatch:patch key:key iv:iv exploit:exploit])
                {
                    Log(@"Failed to patch %@", file);
                    return NO;
                }
            }
        }
    }

    if(![[InstanceManager firmware] makeBootLogo:[[NSBundle mainBundle] pathForResource:@"logo" ofType:@"png"]])
    {
        Log(@"Failed to make boot logo");
        return NO;
    }

    return YES;
}

-(BOOL) actionPatch:(NSString*) file :(NSString*) patch
{
	char* args[5] = {"/usr/bin/bspatch", (char*)[[self safePath:file] UTF8String], (char*)[[self safePath:file] UTF8String], (char*)[[self safePath:patch] UTF8String], NULL};

//    Log(@"patch %@ with %@", [self safePath:file], [self safePath:patch]);

	if(![_secureTask runTaskWithArgs:args])
		return NO;
		
	return YES;
}

-(BOOL) actionAdd:(NSString*) file :(NSString*) path
{
	BOOL isDir = NO;

    char* args[4] = {"/bin/mkdir", "-p", (char*)[[self safePath:[path stringByDeletingLastPathComponent]] UTF8String], NULL};

//    Log(@"mkdir %@", [self safePath:[path stringByDeletingLastPathComponent]]);
    
    if(![_secureTask runTaskWithArgs:args])
        return NO;

	[[NSFileManager defaultManager] fileExistsAtPath:file isDirectory:&isDir];

	char* args2[5] = {"/bin/cp", isDir ? "-vfR" : "-vf", (char*)[[self safePath:file] UTF8String], (char*)[[self safePath:path] UTF8String], NULL};

//    Log(@"cp %@ to %@", [self safePath:file], [self safePath:path]);
	
	if(![_secureTask runTaskWithArgs:args2])
		return NO;
    
    if([[_secureTask output] rangeOfString:NoSpaceLeftString].length > 0)
    {
        Log(@"No free space left");
        return NO;
    }
        
	return YES;
}

-(BOOL) actionReplaceKernel:(NSString*) file :(NSString*) path
{
	char* args[5] = {"/bin/cp", "-vf", (char*)[[self safePath:file] UTF8String], (char*)[[self safePath:path] UTF8String], NULL};

//    Log(@"cp %@ to %@", [self safePath:file], [self safePath:path]);

	if(![_secureTask runTaskWithArgs:args])
		return NO;

	return YES;
}

-(BOOL) actionSetOwner:(NSString*) file :(NSString*) owner
{
	BOOL isDir = NO;
	[[NSFileManager defaultManager] fileExistsAtPath:file isDirectory:&isDir];
	
	char* args[5] = {"/usr/sbin/chown", "-v", (char*)[owner UTF8String], (char*)[[self safePath:file] UTF8String], NULL};

//    Log(@"chown %@", [self safePath:file]);

	if(![_secureTask runTaskWithArgs:args])
		return NO;
    
	return YES;
}

-(BOOL) actionSetPermission:(NSString*) file :(NSString*) permission
{
	BOOL isDir = NO;
	[[NSFileManager defaultManager] fileExistsAtPath:file isDirectory:&isDir];
	
	char* args[5] = {"/bin/chmod", "-v", (char*)[permission UTF8String], (char*)[[self safePath:file] UTF8String], NULL};
	
	if(![_secureTask runTaskWithArgs:args])
		return NO;
		
	return YES;
}

-(BOOL) actionRunScript:(NSString*) file :(NSString*) path
{
	char* args[4] = {"/bin/sh", (char*)[[self safePath:file] UTF8String], (char*)[[self safePath:path] UTF8String], NULL};
    
	if(![_secureTask runTaskWithArgs:args])
		return NO;
        
	return YES;
}

-(NSString*) safePath:(NSString*) string
{
    return [NSString stringWithFormat:@"\"%@\"", string];
}

-(void) handlePortMessage:(NSPortMessage*) portMessage
{
    unsigned int message = [portMessage msgid];
 
    if(message == BuilderStopMessage)
        _abortBuilding = YES;
}

@end