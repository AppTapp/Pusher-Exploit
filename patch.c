#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/sha.h>
#include <openssl/aes.h>
#include "patch.h"
#include "compression.h"

int patch(const char* filename, const char* output)
{
	FILE *in, *out;
    hImg3 headerImg3;
    Img3Element element;
    Img3Element* pElement;
    Img3Element* pNewElement;
    Img3Element* pDataElement;
    hKernel headerKernel;
	unsigned char *inbuf, *outbuf, *end, *p;
	char *sha, *key, *iv;
    unsigned int size, paddedSize;
	KernelVersion kernelVersion;
    int ret = 0;
	
    in = fopen(filename, "rb");
    if(!in)
    {
        fprintf(stderr, "ERR: Could not open file for reading.\n");
        return -1;
    }

    fseek(in, 0, SEEK_END);
    size = ftell(in);
    rewind(in);
	
    if(size < sizeof(hImg3))
    {
        fprintf(stderr, "ERR: Incorrect file. Filesize is less than should be.\n");
        fclose(in);
        return -1;
    }
	
    inbuf = (unsigned char *)malloc(size);
    fread(inbuf, 1, size, in);
    fclose(in);

    p = inbuf;

//    printf("... Check kernel version.\n");

	sha = (char *)malloc(SHA_DIGEST_LENGTH * 2);
	memset(sha, 0, SHA_DIGEST_LENGTH * 2);
	sha1(p, size, &sha);
	
	if(memcmp(sha,"8774EF53BA1A2B9BE367FF91FF577178C86E17C4",SHA_DIGEST_LENGTH * 2) == 0)
	{
		kernelVersion = kv202;
		key = 0;
		iv = 0;

//	    printf("... Kernel version 2.0.2 found.\n");
	}
	else if(memcmp(sha,"E07158EE6B7EF4F91701D6B7BB100393FD39C56D",SHA_DIGEST_LENGTH * 2) == 0)
	{
		kernelVersion = kv210;
		key = "de52cebf74b7747360535fde5c331bd1";
		iv = "2b4764d4c5bdeaa4cea2100eac7c47bb";
		
//	    printf("... Kernel version 2.1 found.\n");
	}
	else if(memcmp(sha,"2A3AA72B97AFD6D0298E43F7686C997B8895C665",SHA_DIGEST_LENGTH * 2) == 0)
	{
		kernelVersion = kv220;
		key = "a3ad8e780bc8148e8e6299d3352b96bc";
		iv = "ff4c66886a10aaea2a8fff0f70dd201a";

//	    printf("... Kernel version 2.2 found.\n");
	}
	else if(memcmp(sha,"755E1992703150C4B3A9DD7CF466E1A1FD56654B",SHA_DIGEST_LENGTH * 2) == 0)
	{
		kernelVersion = kv221;
		key = "f6f00f9369bb19855b9a3d0a69e15a2d";
		iv = "661f05d1599967135b86e82e2377b58d";

//	    printf("... Kernel version 2.2.1 found.\n");
	}	else
	{
    	fprintf(stderr, "ERR: Incorrect firmware version.\n");
    	free(inbuf);
		free(sha);
    	return -1;
	}
	
	free(sha);
	
//    printf("... Begin parsing Img3 file.\n");

    memcpy(&headerImg3, p, sizeof(hImg3));
	
    if(endian_swap(headerImg3.magic) != 'Img3')
    {
        fprintf(stderr, "ERR: Incorrect file. Wrong magic value.\n");
        free(inbuf);
        return -2;
    }

    out = fopen(output, "wb");
    if(!out)
    {
        fprintf(stderr, "ERR: Could not open file for writing.\n");
        free(inbuf);
        return -1;
    }

    p += sizeof(hImg3);
	
    pElement = &element;
	memcpy(&pElement->header, p, sizeof(hImg3Element));
	pElement->data = (unsigned char*)malloc(endian_swap(pElement->header.dataSize));
	memcpy(pElement->data, p + sizeof(hImg3Element), endian_swap(pElement->header.dataSize));
	p += endian_swap(pElement->header.size);
	
	pElement->nextElement = 0;

    if(key != 0 && iv != 0)
    {
        paddedSize = endian_swap(pElement->header.dataSize);
        paddedSize = (paddedSize % AES_BLOCK_SIZE == 0) ? paddedSize : (paddedSize / AES_BLOCK_SIZE) * AES_BLOCK_SIZE;
    
        aes_decrypt(pElement->data, paddedSize, key, iv);
    }
    
	memcpy(&headerKernel, pElement->data, sizeof(hKernel));
	if(endian_swap(headerKernel.magic) == swap32('comp'))
	{
//		printf("... KernelCache file found.\n");

        pNewElement = pElement;
    	
	    while((unsigned int)(p - inbuf) < size)
	    {
		    pNewElement->nextElement = (Img3Element*)malloc(sizeof(Img3Element));
		    pNewElement = pNewElement->nextElement;
    		
		    memcpy(&pNewElement->header, p, sizeof(hImg3Element));
		    pNewElement->data = (unsigned char*)malloc(endian_swap(pNewElement->header.dataSize));
		    memcpy(pNewElement->data, p + sizeof(hImg3Element), endian_swap(pNewElement->header.dataSize));
		    p += endian_swap(pNewElement->header.size);
    		
		    pNewElement->nextElement = 0;
	    }

//        printf("... Decompressing KernelCache file.\n");
		
    	p = pElement->data;
    	size = endian_swap(pElement->header.dataSize);

        p += sizeof(hKernel);
		size = endian_swap(swap32(headerKernel.compressed_size));
		
        outbuf = (unsigned char *)malloc(endian_swap(swap32(headerKernel.uncompressed_size)));
        memset(outbuf, 0, endian_swap(swap32(headerKernel.uncompressed_size)));
        size = decompress_lzss(outbuf, p, size);
		
        if(size == endian_swap(swap32(headerKernel.uncompressed_size)))
        {
//            printf("... Patching KernelCache file.\n");

			if(kernelVersion == kv202)
			{
                outbuf[0x3da62] = 0x00;
                outbuf[0x3da63] = 0x00;
                outbuf[0x371bf0] = 0x00;
                outbuf[0x4203fc] = 0x01;
                outbuf[0x42108c] = 0x01;
			}
			else if(kernelVersion == kv210)
            {
                outbuf[0x3da72] = 0x00;
                outbuf[0x3da73] = 0x00;
                outbuf[0x35dafc] = 0x00;
                outbuf[0x40c3f8] = 0x01;
                outbuf[0x40d088] = 0x01;
            }
			else if(kernelVersion == kv220)
            {
                outbuf[0x3da9a] = 0x00;
                outbuf[0x3da9b] = 0x00;
                outbuf[0x371afc] = 0x00;
                outbuf[0x4243fc] = 0x01;
                outbuf[0x42508c] = 0x01;
            }
			else if(kernelVersion == kv221)
            {
                outbuf[0x3da9a] = 0x00;
                outbuf[0x3da9b] = 0x00;
                outbuf[0x371afc] = 0x00;
                outbuf[0x4243fc] = 0x01;
                outbuf[0x42508c] = 0x01;
            }

            headerKernel.adler32 = swap32(local_adler32(outbuf, size));
            headerKernel.uncompressed_size = swap32(size);

//            printf("... Compressing KernelCache file.\n");

            end = compress_lzss(outbuf, size, outbuf, size);
	        size = (unsigned int)(end - outbuf);
	        headerKernel.compressed_size = swap32(size);
        	
	        headerKernel.adler32 = endian_swap(headerKernel.adler32);
	        headerKernel.uncompressed_size = endian_swap(headerKernel.uncompressed_size);
	        headerKernel.compressed_size = endian_swap(headerKernel.compressed_size);
        	
	        pDataElement = getDataElement(pElement);
	        pDataElement->header.dataSize = sizeof(hKernel) + size;
	        pDataElement->header.size = pDataElement->header.dataSize + sizeof(hImg3Element);

	        pDataElement->header.dataSize = endian_swap(pDataElement->header.dataSize);
	        pDataElement->header.size = endian_swap(pDataElement->header.size);
        	
	        free(pDataElement->data);
            
	        pDataElement->data = (unsigned char*)malloc(endian_swap(element.header.dataSize));
	        memcpy(pDataElement->data, &headerKernel, sizeof(hKernel));
	        memcpy(pDataElement->data + sizeof(hKernel), outbuf, size);

            free(outbuf);

            if(key != 0 && iv != 0)
            {
                paddedSize = endian_swap(pElement->header.dataSize);
                paddedSize = (paddedSize % AES_BLOCK_SIZE == 0) ? paddedSize : (paddedSize / AES_BLOCK_SIZE) * AES_BLOCK_SIZE;
                
                aes_encrypt(pDataElement->data, paddedSize, key, iv);
            }
            else
            {
//                printf("... Skip KBAG section.\n");
                pElement = removeElement(pElement, endian_swap('KBAG'));
            }

	        headerImg3.imageSize = getElementsSize(pElement);
	        headerImg3.size = headerImg3.imageSize + sizeof(hImg3);
	        headerImg3.shshOffset = getSHSHOffset(pElement);

	        outbuf = (unsigned char *)malloc(headerImg3.size);
	        memset(outbuf, 0, headerImg3.size);
        	
	        headerImg3.imageSize = endian_swap(headerImg3.imageSize);
	        headerImg3.size = endian_swap(headerImg3.size);
	        headerImg3.shshOffset = endian_swap(headerImg3.shshOffset);
        	
	        p = outbuf;
	        memcpy(p, &headerImg3, sizeof(hImg3));
	        p += sizeof(hImg3);
        	
	        while(pElement)
	        {
		        memcpy(p, &pElement->header, sizeof(hImg3Element));
		        memcpy(p + sizeof(hImg3Element), pElement->data, endian_swap(pElement->header.dataSize));
		        p += endian_swap(pElement->header.size);
        		
		        pElement = pElement->nextElement;
	        }
        	
	        fwrite(outbuf, 1, endian_swap(headerImg3.size), out);
        }
        else
        {
            fprintf(stderr, "ERR: Incorrect un-compressed size: %d != %d.\n", size, endian_swap(swap32(headerKernel.uncompressed_size)));
            ret = -1;
        }

        free(outbuf);
    }

    freeElements(&element);
    free(inbuf);
	fclose(out);
	
	return ret;
}

Img3Element* getDataElement(Img3Element* pElement)
{
	while(pElement)
	{
		if(pElement->header.magic == endian_swap('DATA'))
        {
//            printf("... Data size %d.\n", endian_swap(pElement->header.dataSize));
            return pElement;
        }

		pElement = pElement->nextElement;
	}
	
	return NULL;
}

unsigned int getElementsSize(Img3Element* pElement)
{
	unsigned int size = 0;
	
	while(pElement)
	{
		size += endian_swap(pElement->header.size);
		
		pElement = pElement->nextElement;
	}
	
	return size;
}

unsigned int getSHSHOffset(Img3Element* pElement)
{
	unsigned int offset = 0;
	
	while(pElement)
	{
		if(pElement->header.magic == endian_swap('SHSH'))
			return offset;

		offset += endian_swap(pElement->header.size);
		
		pElement = pElement->nextElement;
	}
	
	return 0;
}

Img3Element* removeElement(Img3Element* pElement, unsigned int magic)
{
	Img3Element* root = pElement;
	Img3Element* prev = 0;

	while(pElement)
	{
		if(pElement->header.magic == magic)
        {
            if(prev == 0)
                root = pElement->nextElement;
            else
                prev->nextElement = pElement->nextElement;
            
            free(pElement->data);
            free(pElement);
            
            break;
        }
		
        prev = pElement;
		pElement = pElement->nextElement;
	}
    
    return root;
}

void freeElements(Img3Element* pElement)
{
	Img3Element* p;

    free(pElement->data);
	pElement = pElement->nextElement;
	
	while(pElement)
	{
		free(pElement->data);
		
		p = pElement;
		pElement = pElement->nextElement;
		
		free(p);
	}
}

void aes_decrypt(void* p, unsigned int size, const char* key, const char* iv)
{
    AES_KEY dctx;
    unsigned char aes_key[AES_BLOCK_SIZE] = {0};
    unsigned char aes_iv[AES_BLOCK_SIZE] = {0};

    convert_hex(key, aes_key, AES_BLOCK_SIZE);
    convert_hex(iv, aes_iv, AES_BLOCK_SIZE);

    AES_set_decrypt_key( aes_key, 128, &dctx );
    AES_cbc_encrypt(p, p, size, &dctx, aes_iv, AES_DECRYPT);
}

void aes_encrypt(void* p, unsigned int size, const char* key, const char* iv)
{
    AES_KEY ectx;
    unsigned char aes_key[AES_BLOCK_SIZE] = {0};
    unsigned char aes_iv[AES_BLOCK_SIZE] = {0};

    convert_hex(key, aes_key, AES_BLOCK_SIZE);
    convert_hex(iv, aes_iv, AES_BLOCK_SIZE);

    AES_set_encrypt_key( aes_key, 128, &ectx );
    AES_cbc_encrypt(p, p, size, &ectx, aes_iv, AES_ENCRYPT);    
}

void sha1(void* p, unsigned int size, char** buf)
{
	int i;
	SHA_CTX sctx;
    unsigned char sha[SHA_DIGEST_LENGTH] = {0};
	char* pbuf;

	SHA1_Init(&sctx);
	SHA1_Update(&sctx, p, size);
	SHA1_Final(&(sha[0]), &sctx);

	pbuf = *buf;

//	printf("... SHA1 ");

	for(i = 0;i < SHA_DIGEST_LENGTH;i++)
	{
		sprintf(pbuf, "%02X", sha[i]);
//		printf("%02X", sha[i]);
		pbuf += 2;
	}
	
//	printf("\n");
}

void convert_hex(const char* str, unsigned char* bytes, int len)
{
    int slen = (int)strlen(str);
    int byte, rpos, wpos = 0;

    for(rpos = 0; rpos < len; rpos++)
    {
        sscanf(&str[rpos*2], "%02hhx", &byte);
        bytes[wpos++] = (unsigned char)byte;
    }
}

unsigned int endian_swap(unsigned int x)
{
#ifdef __ppc__

    x = swap32(x);
    
#endif

    return x;
}

unsigned short endian_swap16(unsigned short x)
{
#ifdef __ppc__

    x = swap16(x);
    
#endif

    return x;
}

unsigned short swap16(unsigned short x)
{
    x = (x>>8) | 
        (x<<8);

    return x;
}

unsigned int swap32(unsigned int x)
{
    x = (x>>24) | 
        ((x<<8) & 0x00FF0000) |
        ((x>>8) & 0x0000FF00) |
        (x<<24);

    return x;
}