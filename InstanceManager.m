/*!
 @source InstanceManager.m
 @project Pusher
 @author Alexander Maksimenko
 @copyright Copyright (c) 2009 Ripdev. All rights reserved.
 */

#import "MainWindowController.h"
#import "SpotlightSearch.h"
#import "OpenSSLHelper.h"
#import "IPhoneUSB.h"
#import "WizardStepController.h"
#import "MessageManager.h"
#import "Firmware.h"
#import "FirmwareManager.h"
#import "InstanceManager.h"

static FirmwareManager* _firmwareManager;

static MainWindowController* _mainController = nil;
static MessageManager* _messageManager = nil;
static SpotlightSearch* _spotlightSearch = nil;
static BOOL _isUILocked = NO;

static WizardStepController* _stepController = nil;

static IPhoneUSB* _iPhoneUSB;
static Platform _platform = Unknown;
static Firmware* _firmware = nil;
static NSString* _ramdiskPath = nil;

@implementation InstanceManager

+(void) init
{
    _platform = Unknown;
	_firmwareManager = [[FirmwareManager alloc] init];
    _spotlightSearch = [[SpotlightSearch alloc] init];
    _messageManager = [[MessageManager alloc] init];
}

+(void) unInit
{
    if(_iPhoneUSB)
    {
        [_iPhoneUSB stopService];
        [_iPhoneUSB release];
        _iPhoneUSB = nil;
    }

    [_firmware release];
    _firmware = nil;
    
	[_firmwareManager release];
    _firmwareManager = nil;
    
    [_messageManager release];
    _messageManager = nil;
    
    [_spotlightSearch release];
    _spotlightSearch = nil;
    
    [InstanceManager deleteTempFiles];
}

+(FirmwareManager*) firmwareManager
{
    return _firmwareManager;
}

+(MainWindowController*) mainController
{
    return _mainController;
}

+(void) setMainController:(MainWindowController*) value
{
    _mainController = value;
}

+(BOOL) isUILocked
{
    return _isUILocked;
}

+(void) setUILocked:(BOOL) value
{
    _isUILocked = value;
}

+(void) setPushState:(PushButtonState) state
{
    [_mainController setPushState:state];
}

+(void) setText:(NSString*) text
{
    [_mainController setText:text];
}

+(void) setButtonText:(NSString*) text
{
    [_mainController setButtonText:text];
}

+(void) enableSun:(BOOL) value
{
    [_mainController enableSun:value];
}

+(WizardStepController*) stepController
{
    return _stepController;
}

+(void) setStepController:(WizardStepController*) stepController
{
    _stepController = stepController;
    [_stepController begin];
}

+(Platform) platform
{
    return _platform;
}

+(void) setPlatform:(Platform) value
{
    _platform = value;
}

+(Firmware*) firmware
{
    return _firmware;
}

+(void) setFirmware:(Firmware*) value
{
    [_firmware release];
    _firmware = [value retain];
    
    if(_firmware != nil)
        [[NSUserDefaults standardUserDefaults] setObject:[_firmware path] forKey:LastFirmwarePathKey];
}

+(NSString*) ramdiskPath
{
    return _ramdiskPath;
}

+(void) setRamdiskPath:(NSString*) value
{
    [_ramdiskPath release];
    _ramdiskPath = [value copy];    
}

+(NSArray*) searchFilesWithContentType:(NSString*) contentType name:(NSString*) name size:(int) size
{
    return [_spotlightSearch searchFilesWithContentType:contentType name:name size:size];
}

+(void) deleteTempFiles
{
    NSFileManager* fileManager = [NSFileManager defaultManager];

    if([fileManager fileExistsAtPath:SystemTempDir])
        [fileManager removeFileAtPath:SystemTempDir handler:nil];
}

+(BOOL) checkFreeSpace:(unsigned long long) bytes atPath:(NSString*) path
{
    NSFileManager* fileManager = [NSFileManager defaultManager];
    NSDictionary* attrs = [fileManager fileSystemAttributesAtPath:path];

    return ([[attrs objectForKey:NSFileSystemFreeSize] unsignedLongLongValue] > bytes);
}

+(void) runLoop
{
    NSEvent* event;
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];

    @try
    {
        while(event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate dateWithTimeIntervalSinceNow:0.1] inMode:NSDefaultRunLoopMode dequeue:YES])
            if([event type] == NSAppKitDefined || [event type] == NSSystemDefined)
                [NSApp sendEvent:event];
    }
    @catch (NSException *ex)
    {
        Log(@"%@ %@", [ex name], [ex reason]);
    }
    @finally
    {
        [pool release];
    }
}

+(BOOL) checkURL:(NSURL*) url
{
    NSURLRequest* request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:5];
    NSURLResponse* response = nil;
    NSError* error = nil;
    
    [NSURLConnection sendSynchronousRequest:request returningResponse:&response error:&error];
    
    return (error == nil);
}

@end

@implementation InstanceManager (IPhoneUSB)

+(void) usbDelegateAdd:(id) delegate
{
    Log(@"%@ Add usb delegate", delegate);

    if(_iPhoneUSB == nil)
    {
        _iPhoneUSB = [[IPhoneUSB alloc] init];
        [_iPhoneUSB startService];
    }

    [_iPhoneUSB setDelegate:delegate];
}

+(void) usbDelegateRemove:(id) delegate
{
    Log(@"%@ Remove usb delegate", delegate);

    if([_iPhoneUSB delegate] == delegate)
        [_iPhoneUSB setDelegate:nil];
}

+(void) usbSendCommand:(NSString*) cmd
{
    [_iPhoneUSB sendCommand:cmd];    
}

+(void) usbUploadFile:(NSString*) file
{
    [_iPhoneUSB uploadFile:file];
}

@end

@implementation InstanceManager (StringAndMessage)

+(void) stopMessage
{
    [_messageManager stopFloatingMessage];
}

+(void) showBubble:(NSAttributedString*) text onSide:(MAWindowPosition) side ofView:(NSView*) view withTimeout:(int) seconds andDismissMode:(DismissMode) dismissMode
{
    [_messageManager showBubble:text onSide:side ofView:view withTimeout:seconds andDismissMode:dismissMode];
}

+(void) showError:(NSAttributedString*) text withTimeout:(int) seconds buttons:(NSArray*) buttons
{
    NSBeep();
    [_messageManager showMessage:text ofKind:ErrorMessage withTimeout:seconds buttons:buttons];
}

+(void) showMessage:(NSAttributedString*) text withTimeout:(int) seconds buttons:(NSArray*) buttons
{
    [_messageManager showMessage:text ofKind:TextMessage withTimeout:seconds buttons:buttons];
}

@end
