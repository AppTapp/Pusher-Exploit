/*!
 @source FirmwareManager.m
 @project Pusher
 @author Alexander Maksimenko
 @copyright Copyright (c) 2009 Ripdev. All rights reserved.
 */

#import "OpenSSLHelper.h"
#import "Firmware.h"
#import "FirmwareBundle.h"
#import "FirmwareManager.h"
#import "FirmwareDownload.h"

@implementation FirmwareManager

-(id) init
{
	self = [super init];

	_firmwareBundles = [[NSMutableArray alloc] init];
	[self loadFirmwareBundles];
	
	return self;
}

-(void) dealloc
{
	[_firmwareBundles release];
	
	[super dealloc];
}

-(void) loadFirmwareBundles
{
	[_firmwareBundles removeAllObjects];
	
	NSString* path = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:@"FirmwareBundles"];
	NSFileManager* fm = [NSFileManager defaultManager];
	NSArray* files = [fm directoryContentsAtPath:path];
	int i = 0;
	int count = [files count];
	
	for(i = 0; i < count; i++)
	{
		NSString* bundlePath = [files objectAtIndex:i];
		if([[bundlePath pathExtension] isEqualToString:@"bundle"])
		{
			bundlePath = [path stringByAppendingPathComponent:bundlePath];
			NSDictionary* info = [NSDictionary dictionaryWithContentsOfFile:[bundlePath stringByAppendingPathComponent:@"Info.plist"]];
			if(info != nil)
			{
				FirmwareBundle* fwb = [[[FirmwareBundle alloc] initWithInfo:info path:bundlePath] autorelease];
                if (fwb != nil)
                    [_firmwareBundles addObject: fwb];
			}
		}
	}
}

-(Firmware*) firmwareForFile:(NSString*) file platform:(Platform) platform
{
    NSString* shaValue = nil;

    NSEnumerator* enumerator = [_firmwareBundles objectEnumerator];
    FirmwareBundle* firmwareBundle;
    while(firmwareBundle = [enumerator nextObject])
        if([firmwareBundle platform] == platform)
        {
            if(shaValue == nil)
                shaValue = [OpenSSLHelper shaStringForFile:file];

            if([shaValue compare:[firmwareBundle sha1] options:NSCaseInsensitiveSearch] == NSOrderedSame)
                return [[[Firmware alloc] initWithBundle:firmwareBundle path:file] autorelease];
        }

    return nil;
}

-(Firmware*) firmwareByFile:(NSString*) file platform:(Platform) platform
{
    NSString* shaValue = nil;

    NSEnumerator* enumerator = [_firmwareBundles objectEnumerator];
    FirmwareBundle* firmwareBundle;
    while(firmwareBundle = [enumerator nextObject])
        if([[file lastPathComponent] isEqualToString:[firmwareBundle filename]] && [firmwareBundle platform] == platform)
        {
            if(shaValue == nil)
                shaValue = [OpenSSLHelper shaStringForFile:file];

            if([shaValue compare:[firmwareBundle sha1] options:NSCaseInsensitiveSearch] == NSOrderedSame)
                return [[[Firmware alloc] initWithBundle:firmwareBundle path:file] autorelease];
        }

    return nil;
}

-(FirmwareDownload*) downloadFirmwareForPlatform:(Platform) platform delegate:(id) delegate
{
    NSEnumerator* enumerator = [_firmwareBundles objectEnumerator];
    FirmwareBundle* firmwareBundle = nil;
    while(firmwareBundle = [enumerator nextObject])
        if([firmwareBundle platform] == platform)
            break;

    if(firmwareBundle == nil)
        return nil;
        
    NSString* downloadUrl = [firmwareBundle downloadUrl];
    NSURL* url = [NSURL URLWithString:downloadUrl];
    NSURLRequest* request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:60.0];
    NSURLDownload* download = [[NSURLDownload alloc] initWithRequest:request delegate:delegate];

    if(download)
    {
        NSString* path = [[NSHomeDirectory() stringByAppendingPathComponent:@"Desktop"] stringByAppendingPathComponent:[downloadUrl lastPathComponent]];
        FirmwareDownload* firmwareDownload = [[[FirmwareDownload alloc] initWithFirmwareFile:path andDownload:download] autorelease];
        
        [download setDestination:path allowOverwrite:YES];
        
        return firmwareDownload;
    }
    
    return nil;
}

@end
